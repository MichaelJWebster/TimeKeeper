/**
 * 
 */
/**
 * @author michaelwebster
 *
 */
package Tk_Configuration;package Tk_Configuration;

public enum Tk_ClockType
{
	Unknown("Unknown"),
	Digital("Digital"),
	Analog("Analog");
	
	private Tk_ClockType(String ctype)
	{
	}

	public static Tk_ClockType getClockType(String clock_string)
	{
		if (clock_string.equals(Digital.name()))
		{
			return Digital;
		}
		else if (clock_string.equals(Analog.name()))
		{
			return Analog;
		}
		else
		{
			return Unknown;
		}
	}

	public static void main(String[] args)
	{
		for (Tk_ClockType c: Tk_ClockType.values())
		{
			System.out.printf("ClockType %s has ordinal %d\n",
					c.name(), c.ordinal());
		}
		
		Tk_ClockType tc = Tk_ClockType.getClockType("Digital");
		System.out.println("Digital gets you " + tc.name());
		tc = Tk_ClockType.getClockType("Analog");
		System.out.println("Analog gets you " + tc.name());
		tc = Tk_ClockType.getClockType("Blibble");
		System.out.println("Blibble gets you " + tc.name());
		
	}
}
/**
 * 
 */
package Tk_Configuration;
import java.util.AbstractSequentialList;
import java.io.*;
import java.net.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.event.*;

// Imports for xml.
import org.w3c.dom.*;
import org.xml.sax.*;
import Tk_utils.Tk_XmlUtil;
import javax.xml.parsers.*;
import javax.xml.validation.*;

/**
 * <p>Tk_TaskCollection represents current, retired and deleted lists of task
 * names. The class and it's lists are instantiated from the task information
 * recorded in the xml file TK_TaskList.xml. The xml read from, and written
 * back to that file are validated using an xml schema, TK_TaskList.xsd.</p>
 * 
 * <p>The class makes use of <code>Tk_TaskList</code> model's to keep track
 * of tasks. These lists can be shared with a combo box, and also edited at
 * the same time, so that tasks can be added or deleted from the various lists.
 * 
 * Changes to the lists in this class can be, and are, written back to the
 * TK_TaskList.xml file.
 *
 * @author michaelwebster
 *
 * FIXME: Need a finalize method to ensure the current state of the xml is
 * written back to m_file.
 */
public class Tk_TaskCollection // implements ActionListener
{
	/*
	 * Static xml tag srings.
	 */
	private final static String TK_TaskList 		= "TK_TaskList";
	private final static String TK_CurrentTasks 	= "TK_CurrentTasks";
	private final static String TK_RetiredTasks 	= "TK_RetiredTasks";
	private final static String TK_DeletedTasks 	= "TK_DeletedTasks";	
	private final static String TK_TaskName 		= "TK_TaskName";
	
	/*
	 * Instance attributes.
	 */
	private String 				m_xmlFileName			= null;
	private String				m_schemaFileName = null;
	private Document			m_doc					= null;
	
	//The DefaultComboBoxModels containing the tasks for use in the UI combo box.
	private Tk_TaskListModel m_currentList		= null;
	private Tk_TaskListModel m_retiredList		= null;
	private Tk_TaskListModel m_deletedList		= null;	

	/*
	 * Construct the Tk_TaskCollection object by:
	 * - Find the files indicated by uri_string and schema_string.
	 * - Create a Schema object from the schema file.
	 * - Create a validating parser incorporating the schema, and attempt to
	 * 	 parse the file passed in as uri_string.
	 * - Add TK_TaskName entries from the xml file to the m_currentList and
	 *   m_retiredList according to which section they are in.
	 *
	 * @param uri_string		The URI for the xml file containing the lists
	 *                          of tasks for the time keeper.
	 * @param schema_string     The schema for the xml file above.
	 */
	public Tk_TaskCollection(String xml_name, String schema_name)
	{
		/*
		 * Create the URI for the xml task list from the supplied uri_string.
		 */
		m_xmlFileName = xml_name;
		m_schemaFileName = schema_name;
		m_doc = Tk_XmlUtil.createDocument(m_xmlFileName, m_schemaFileName);
		populateTaskLists();
	}

	/**
	 * Extract task name information from the TK_TaskList xml file, and
	 * populate the m_currentList and m_retiredLists. 
	 */
	private void populateTaskLists()
	{
		m_currentList = new Tk_TaskListModel();		//DefaultComboBoxModel<String>();
		m_retiredList = new Tk_TaskListModel();		//DefaultComboBoxModel<String>();
		m_deletedList = new Tk_TaskListModel(); 	//DefaultComboBoxModel<String>();
		
		Element doc_element = m_doc.getDocumentElement();

		// Get the list of current tasks.
		Element el = Tk_XmlUtil.getFirstElement(doc_element, TK_CurrentTasks);
		if (null != el)
		{
			NodeList ct_nodes = el.getElementsByTagName(Tk_TaskCollection.TK_TaskName);
			for (int i = 0; i < ct_nodes.getLength(); i++)
			{
				Element tn_el = (Element)ct_nodes.item(i);
				String task_name = Tk_XmlUtil.getSimpleElementText(tn_el);
				m_currentList.addElement(task_name);
			}
		}
		
		el = Tk_XmlUtil.getFirstElement(doc_element, TK_RetiredTasks);
		if (null != el)
		{
			NodeList ct_nodes = el.getElementsByTagName(Tk_TaskCollection.TK_TaskName);
			for (int i = 0; i < ct_nodes.getLength(); i++)
			{
				Element tn_el = (Element)ct_nodes.item(i);
				String task_name = Tk_XmlUtil.getSimpleElementText(tn_el);
				m_retiredList.addElement(task_name);
			}
		}
		
		el = Tk_XmlUtil.getFirstElement(doc_element, TK_DeletedTasks);
		if (null != el)
		{
			NodeList ct_nodes = el.getElementsByTagName(Tk_TaskCollection.TK_TaskName);
			for (int i = 0; i < ct_nodes.getLength(); i++)
			{
				Element tn_el = (Element)ct_nodes.item(i);
				String task_name = Tk_XmlUtil.getSimpleElementText(tn_el);
				m_deletedList.addElement(task_name);
			}
		}

	}

	/**
	 * The Tk_EditTasks class has just finished running, and we need to
	 * reconcile our lists with the updated versions. If the Ok Button was
	 * clicked, then we also need to update the Dom, and write it out
	 * to our xml file.
	 *
	 * @param ok_clicked   	true  => 	The Tk_EditTasks dialog had its ok
	 * 									button clicked.
	 * 						false =>	The Tk_EditTasks dialog was cancelled.
	 * 					
	 */
	public void reconcileModels(boolean ok_clicked)
	{
		m_currentList.reconcileLists(ok_clicked);
		m_retiredList.reconcileLists(ok_clicked);
		m_deletedList.reconcileLists(ok_clicked);
		DefaultComboBoxModel<String>dcb = 	m_currentList.getStaticList();
		if (dcb.getSize() > 0)
		{
			dcb.setSelectedItem(dcb.getElementAt(0));
		}
		
		if (ok_clicked)
		{
			updateDom();
			writeBackDom();
		}
	}
	
	/**
	 * Rewrite the Current, Retired and Deleted task lists into the DOM, and
	 * write the DOM back to it's file.
	 */
	private void updateDom()
	{
		Document doc = Tk_XmlUtil.createEmptyDom(m_schemaFileName);

		Node root = doc.createElement(TK_TaskList);
		doc.appendChild(root);
		Node c_tasks = doc.createElement(TK_CurrentTasks);
		root.appendChild(c_tasks);
		Node r_tasks = doc.createElement(TK_RetiredTasks);
		root.appendChild(r_tasks);
		Node d_tasks = doc.createElement(TK_DeletedTasks);
		root.appendChild(d_tasks);
		
		// Create and add the task name nodes for the current list.
		DefaultComboBoxModel<String>tasks = m_currentList.getStaticList();
		for (int i = 0; i < tasks.getSize(); i++)
		{
			String tname = tasks.getElementAt(i);
			Node tname_node = doc.createElement(TK_TaskName);
			c_tasks.appendChild(tname_node);
			tname_node.appendChild(doc.createTextNode(tname));
		}

		// Create and add the task name nodes for the retired list.
		tasks = m_retiredList.getStaticList();
		for (int i = 0; i < tasks.getSize(); i++)
		{
			String tname = tasks.getElementAt(i);
			Node tname_node = doc.createElement(TK_TaskName);
			r_tasks.appendChild(tname_node);
			tname_node.appendChild(doc.createTextNode(tname));
		}
		
		// Create and add the task name nodes for the retired list.
		tasks = m_deletedList.getStaticList();
		for (int i = 0; i < tasks.getSize(); i++)
		{
			String tname = tasks.getElementAt(i);
			Node tname_node = doc.createElement(TK_TaskName);
			d_tasks.appendChild(tname_node);
			tname_node.appendChild(doc.createTextNode(tname));
		}
		m_doc = doc;
	}

	/**
	 * Write the DOM back to the task list xml file. 
	 */
	private void writeBackDom()
	{
		try
		{
			File xml_file = new File(m_xmlFileName);
			FileWriter fw = new FileWriter(xml_file);
			fw.write(Tk_XmlUtil.formatDoc(getDom()));
			fw.close();
		}
		catch (IOException e)
		{
			System.out.println("Tk_TaskCollection: writeBackDom IOException.");
			System.out.println(e.getMessage());
			System.exit(-1);
		}
	}

	/*
	 * Create getter and or setter methods for these attributes:
	 *
	 * private String 				m_taskListURIString		= null;
	 * private String				m_schemaURIString		= null;
	 * private URI         		m_uri					= null;
	 * private URI					m_schemaURI				= null;
	 * private File				m_file					= null;
	 * private File				m_schemaFile			= null;
	 * private Document			m_doc					= null;
	 * private DocumentBuilder 	m_docBuilder			= null;
	 * private Schema      		m_schema				= null;
	 * private DefaultComboBoxModel<String>m_currentList	= null;
	 * private DefaultComboBoxModel<String>m_retiredList	= null;
	 */
	/**
	 * Return the Dom that represents the current state of the task lists.
	 *
	 * @return The Dom object that represents the current state of the task
	 * lists.
	 */
	public Document getDom()
	{
		return m_doc;
	}

	/**
	 * Return the name of the TK_TaskList.xml file.
	 *
	 * @return	The filename for the task list xml file.
	 */
	public String getTaskListFileName()
	{
		return m_xmlFileName;
	}
	
	/**
	 * Get the xml schema file's name.
	 *
	 * @return 	The name of the file containing the task list xsd schema.
	 */
	public String getSchemaFileName()
	{
		return m_schemaFileName;
	}

	/**
	 * Get the up to date, and not for editing version of the current task
	 * list.
	 *
	 * @return The up to date and non-changing version of the current list.
	 */
	public DefaultComboBoxModel<String>getCurrentList()
	{
		return m_currentList.getStaticList();
	}
	
	/**
	 * Get the updatable version of current task list.
	 *
	 * @return The up to date and updatable version of the current task list.
	 */
	public DefaultComboBoxModel<String>getCurrentListUpdate()
	{
		return m_currentList.getUpdateList();
	}
	
	/**
	 * Get the up to date, and not for editing version of the retired task
	 * list.
	 *
	 * @return The up to date and non-changing version of the retired list.
	 */
	public DefaultComboBoxModel<String>getRetiredList()
	{
		return m_retiredList.getStaticList();
	}
	
	/**
	 * Get the updatable version of retired task list.
	 *
	 * @return The up to date and updatable version of the retired task list.
	 */
	public DefaultComboBoxModel<String>getRetiredListUpdate()
	{
		return m_retiredList.getUpdateList();
	}

	/**
	 * Get the up to date, and not for editing version of the deleted task
	 * list.
	 *
	 * @return The up to date and non-changing version of the deleted list.
	 */
	public DefaultComboBoxModel<String>getDeletedList()
	{
		return m_deletedList.getStaticList();
	}
	
	/**
	 * Get the updatable version of deleted task list.
	 *
	 * @return The up to date and updatable version of the deleted task list.
	 */
	public DefaultComboBoxModel<String>getDeletedListUpdate()
	{
		return m_deletedList.getUpdateList();
	}

	/**
	 * Debug method for printing the static version of the current task list to
	 * System.out.
	 */
	public void printCurrentList()
	{
		int length = m_currentList.getStaticList().getSize();
		
		for (int i = 0; i < length; ++i)
		{
			System.out.printf
			(
				"%s\n", 
				m_currentList.getStaticList().getElementAt(i)
			);
		}
	}
	
	/**
	 * Debug method for printing out the contents of the static version of the
	 * retired task list.
	 */
	public void printRetiredList()
	{
		int length = m_retiredList.getStaticList().getSize();
		
		for (int i = 0; i < length; ++i)
		{
			System.out.printf
			(
				"%s\n",
				m_retiredList.getStaticList().getElementAt(i)
			);
		}
	}

	/**
	 * Debug method for printing out the contents of the static version of the
	 * deleted task list.
	 */
	public void printDeletedList()
	{
		int length = m_deletedList.getStaticList().getSize();
		
		for (int i = 0; i < length; ++i)
		{
			System.out.printf
			(
				"%s\n",
				m_deletedList.getStaticList().getElementAt(i)
			);
		}
	}
	
	/**
	 * Debug method for printing this task collection's dom representation.
	 */
	public void printDom()
	{
		System.out.printf("%s", Tk_XmlUtil.formatDoc(getDom()));
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		/*if (args.length != 2)
		{
			System.out.println("Wrong number of arguments supplied to Tk_TaskCollection.");
			System.exit(-1);
		}*/

		String xml_file =
				"/Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/Tk_TaskList.xml"; 
		String xsd_file =
				"/Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/Tk_TaskList.xsd";
		
		Tk_TaskCollection tc = new Tk_TaskCollection(xml_file, xsd_file);
		
		System.out.println("The current DOM is:");
		System.out.printf("%s", Tk_XmlUtil.formatDoc(tc.getDom()));
		
		// Try changing the lists.
		DefaultComboBoxModel<String>dc = tc.getCurrentListUpdate();
		System.out.printf("\ncurrent: Element at 1 is: %s\n", dc.getElementAt(1));
		dc.removeElementAt(1);
		dc = tc.getRetiredListUpdate();
		System.out.printf("retired: Element at 1 is: %s\n", dc.getElementAt(1));
		dc.removeElementAt(1);
		dc = tc.getDeletedListUpdate();
		System.out.printf("deleted: Element at 1 is: %s\n", dc.getElementAt(1));
		dc.removeElementAt(1);
		
		tc.reconcileModels(true);
		System.out.println("The updated DOM is:");
		System.out.printf("%s", Tk_XmlUtil.formatDoc(tc.getDom()));
	}
}
package Tk_Configuration;
import javax.swing.*;
import javax.swing.event.*;

import java.lang.IllegalStateException;

/**
 * Tk_TaskListModel is a holder for two lists, one that can be used as the
 * model for a combo box, and one that can be concurrently updated without
 * effecting the first list. These two lists are called m_staticList and
 * m_updateList respectively. They are both of type DefaultComboBoxModel.
 * 
 * @author michaelwebster
 */
public class Tk_TaskListModel implements ListDataListener
{
	// The non-updateable list for use in a combo box.
	DefaultComboBoxModel<String> m_staticList = null;
	// The updateable copy, that can be modified by an external task.
	DefaultComboBoxModel<String> m_updateList = null;
	// The dirty flag indicates that the update list has been obtained by
	// some external object, and that we cannot accept changes to the
	// static list until the update list has been returned, or finished
	// with.
	boolean m_dirtyFlag = true;
	
	/**
	 * Create empty static and update lists, and set this instance clean.
	 */
	public Tk_TaskListModel()
	{
		m_staticList = new DefaultComboBoxModel<String>();
		m_updateList = new DefaultComboBoxModel<String>();
		m_dirtyFlag = false;
	}
	
	/**
	 * Add a task name (string) element to the Task list model if this instance
	 * is not dirty.
	 *
	 * @param task_name		The name of the task to be added to the list.
	 *
	 * @throws IllegalStateException in the case that an addition to the list
	 * is attempted when the model is dirty.
	 */
	public void addElement(String task_name) throws IllegalStateException
	{
		if (!m_dirtyFlag)
		{
			m_staticList.addElement(task_name);
		}
		else
		{
			IllegalStateException ise =
				new IllegalStateException
				(
					"Error: Elements cannot be added to the TkTaskListModel when it is dirty.\n"
					+
					"The state may be returned to clean by calling the reconcileLists() method.\n"
				);
			throw(ise);
		}
	}
	
	/**
	 * Add all the task name strings from task_list into this object's static
	 * list.
	 * @param task_list		A list of strings to be added to this model.
	 *
	 * @throws IllegalStateException in case the update list is out for
	 * possible editing when this method is called.
	 */
	public void setStaticList(DefaultComboBoxModel<String> task_list)
			throws IllegalStateException
	{
		if (!m_dirtyFlag)
		{
			for (int i = 0; i < task_list.getSize(); i++)
			{
				m_staticList.addElement(task_list.getElementAt(i));
			}
		}
		else
		{
			IllegalStateException ise =
				new IllegalStateException
				(
					"Error: Elements cannot be added to the TkTaskListModel when it is dirty.\n"
					+
					"The state may be returned to clean by calling the reconcileLists() method.\n"
				);
			throw(ise);
		}
	}
	
	/**
	 * Return the static list part of the model for use in a Combo Box, or in
	 * some other way.
	 *
	 * @return The static part of this list model.
	 */
	public DefaultComboBoxModel<String>getStaticList()
	{
		return m_staticList;
	}
	
	/**
	 * If the update list is not out for editing, set it up to be the same as
	 * the static list. Before returning the update list, add a list data
	 * listener to it.
	 *  
	 * @return The update list for possible editing.
	 */
	public DefaultComboBoxModel<String>getUpdateList()
	{
		if  (!m_dirtyFlag)
		{
			m_updateList.removeAllElements();
			for (int i = 0; i < m_staticList.getSize(); i++)
			{
				m_updateList.addElement(m_staticList.getElementAt(i));
			}
			m_updateList.addListDataListener(this);
		}
		else
		{
			IllegalStateException ise =
				new IllegalStateException
				(
					"Error: Elements cannot be added to the TkTaskListModel when it is dirty.\n"
					+
					"The state may be returned to clean by calling the reconcileLists() method.\n"
				);
			throw(ise);
		}
		return m_updateList;
	}
	
	/**
	 * The update list has been updated and is valid, so set the static list
	 * to be the same as the changed update list.
	 *
	 * @param valid		true => All the changes to the update list are to be
	 * 							reflected to the static list.
	 * 					false => Don't update the static list.
	 */
	public void reconcileLists(boolean valid)
	{
		if (valid)
		{
			m_staticList.removeAllElements();
			for (int i = 0; i < m_updateList.getSize(); i++)
			{
				m_staticList.addElement(m_updateList.getElementAt(i));
			}
		}
		m_updateList.removeAllElements();
		m_updateList.removeListDataListener(this);
		m_dirtyFlag = false;
	}
	
	/**
	 * The update list has changed, so set the dirty flag. 
	 */
	@Override
	public void intervalAdded(ListDataEvent e)
	{
		m_dirtyFlag = true;
	}

	/**
	 * The update list has changed, so set the dirty flag. 
	 */
	@Override
	public void intervalRemoved(ListDataEvent e)
	{
		m_dirtyFlag = true;		
	}

	/**
	 * The update list has changed, so set the dirty flag. 
	 */
	@Override
	public void contentsChanged(ListDataEvent e)
	{
		m_dirtyFlag = true;		
	}
	
	/**
	 * Debug method for printing out a DefaultComboBox<String> model.
	 *
	 * @param l A default combo box model to be printed.
	 */
	private static void printList(DefaultComboBoxModel<String>l)
	{
		int length = l.getSize();
		
		for (int i = 0; i < length; ++i)
		{
			System.out.printf(">>>>>>> %s <<<<<<<<<<<\n", l.getElementAt(i));
		}
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		String xml_file = 
				"file:///Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xml";
		String xsd_file = 
				"file:////Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xsd";
		Tk_TaskCollection tc = 
			new Tk_TaskCollection
			(
				xml_file,
				xsd_file
			);
		
		Tk_TaskListModel tklm = new Tk_TaskListModel();
		tklm.setStaticList(tc.getCurrentList());
		
		tc.printCurrentList();
		DefaultComboBoxModel<String>dcm = tklm.getUpdateList();
		System.out.println("UpdateList is now:");
		Tk_TaskListModel.printList(dcm);
		
		/*
		 * Remove an element.
		 */
		dcm.removeElementAt(0);
		System.out.println("\nRemoved an element from the update list.");
		System.out.println("UpdateList is now:");
		Tk_TaskListModel.printList(dcm);
		System.out.println("StaticList is now:");
		Tk_TaskListModel.printList(tklm.getStaticList());
		
		/*
		 * Remove a second element.
		 */
		dcm.removeElementAt(2);
		System.out.println("\nRemoved an element from the update list.");
		System.out.println("UpdateList is now:");
		Tk_TaskListModel.printList(dcm);
		System.out.println("StaticList is now:");
		Tk_TaskListModel.printList(tklm.getStaticList());
		
		/**
		 * Reconcile the lists:
		 */
		tklm.reconcileLists(true);
		System.out.println("\n\nReconciled StaticList is now:");
		Tk_TaskListModel.printList(tklm.getStaticList());

	}
}
/**
 * 
 */
/**
 * @author michaelwebster
 *
 */
package Tk_Gui;package Tk_Gui;

import java.util.*;
import java.awt.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

/**
 * <p>Bar Draws a coloured bar of a certain width on a canvas. The following
 * parameters give it the information it needs to do it's job:
 * <ol>
 * <li>An orientation (Horizontal or Vertical)</li>
 * <li>A direction of growth (Up, Down, Left or Right)</li>
 * <li>A colour.</li>
 * <li>An origin point that, depending on the orientation, or dirction of
 *    growth, will be the position of the top left, bottom left, or top right
 *    corner of the bar.</li>
 * <li>The width of the bar,</li>
 * <li>A Graphics2D instance,</li>
 * <li>A minimum and maximum length or height of the bar.</li>
 * <li>A source of events that cause the update of the bar.</li>
 * <li>A relationship between the quantity received in the events and the
 * 	  size to display on screen.</li>
 * </ol>
 * </p>
 * 
 * @author michaelwebster
 *
 */
public class Tk_Bar extends Tk_BarChartEntry
{
	private Rectangle2D.Double m_bar	= null;
	
	/**
	 * The name of the bar chart entry.
	 */
	private String m_name				= null;
	
	/**
	 * The color of this bar.
	 */
	private Color m_colour				= null;
	
	public static final long MinWidth		= 20;
	public static final long PrefWidth		= 20;
	public static final long MaxWidth		= 40;

	public Tk_Bar
	(
		Tk_GraphDirection 		dir,
		String					name,
		Graphics2D				canvas,
		Point2D.Double			origin,
		long					initial_width,
		long					initial_height,
		Tk_BarChartEntry		parent
	)
	{
		super(dir, canvas, origin, initial_width, initial_height, parent);
		m_name = name;
		createBar();
	}

	public void createBar()
	{
		m_bar = 
			new Rectangle2D.Double
			(
				getOrigin().x,
				getOrigin().y - getInitialHeight(),
				getWidth(),
				getHeight()
			);
		m_colour = this.getColour(m_name);
	}

	@Override
	public long getMinimumWidth()
	{
		return MinWidth;
	}
	
	@Override
	public long getPreferredWidth()
	{
		return PrefWidth;
	}

	@Override
	public long getMaximumWidth()
	{
		return MaxWidth;
	}

	@Override
	public void paint(Graphics2D g2)
	{
		Stroke s = new BasicStroke(1);
		g2.setStroke(s);
		g2.setColor(Color.black);
		g2.draw(m_bar);
		Color bar_color = getColour(getName());
		g2.setColor(bar_color);
		g2.fill(m_bar);
		g2.setColor(Color.black);
	}
	
	@Override
	public void setWidth(long new_width)
	{
		m_width = new_width;
	}
	
	@Override
	public void setHeight(long new_height)
	{
		m_height = new_height;
	}
	
	@Override
	public void setOrigin(Point2D.Double new_origin)
	{
		m_origin = new_origin;
	}
	
	public void changeBar(long new_width, long new_height, Point2D.Double new_origin)
	{
		System.out.printf("In Tk_Bar.changeBar for bar %s\n", getName());
		
		System.out.printf("Tk_Bar.changeBar: Current origin = %s current width = %d, current_height = %d\n",
				m_origin.toString(), getWidth(), getHeight());
		System.out.printf("Tk_Bar.changeBar: Setting origin = %s new_width = %d, new_height = %d\n",
				new_origin.toString(), new_width, new_height);
		setWidth(new_width);
		setHeight(new_height);
		setOrigin(new_origin);
		createBar();
	}
	
	public String getName()
	{
		return m_name;
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub

	}

}
package Tk_Gui;

import java.util.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.geom.Rectangle2D.Double;
import javax.swing.*;

/**
 *
 * <p>A <code>Tk_ChartEntry</code> is either a <code>Tk_Bar</code> or a
 * <code>Tk_Container</code>. That is, the <code>Tk_ChartEntry</code>
 * class and it's subclasses are an implementation of the Composite design
 * pattern.</p> 
 * 
 * <p>The following parameters give it the information it needs to do its
 * job:
 * <ol> 
 * <li>A direction of growth (Up, Down, Left or Right)</li>
 * <li>An origin point that, depending on the orientation, or direction of
 * growth, will be the position of the top left, bottom left, or top right
 * corner of the bar.</li>
 * <li>The width of the <code>Tk_CharEntry</code>,</li>
 * <li>A Graphics2D instance for drawing into,</li>
 * <li>A minimum and maximum length or height of the Tk_CharEntry.</li>
 * </ol>
 * </p>
 *
 * <p>Along with the above initialization parameters, the
 * <cod>Tk_ChartEntry</code> container must be able to contain children of
 * type <code>Tk_ChartEntry</code>. Due to the fact that a
 * <code>Tk_ChartEntry</code> object may need to contact its parent,
 * <code>Tk_ChartEntry</code> will also include a parent reference.</p>
 */
public abstract class Tk_BarChartEntry implements Tk_ChartEntry
{
	/**
	 * The graph orientation can be vertical or horizontal.
	 */
	private Tk_GraphDirection m_growDirection = Tk_GraphDirection.Illegal;
	
	/**
	 * The parent of this <code>Tk_ChartEntry</code>.
	 */
	private Tk_BarChartEntry m_parent = null;
	
	/**
	 * The canvess on which this <code>Tk_ChartEntry</code> and it's children
	 * can paint.
	 */
	private Graphics2D m_canvas = null;
	
	/**
	 * The origin for this Tk_ChartEntry element.
	 */
	protected Point2D.Double m_origin = null;
	
	/**
	 * The outline rectangle that completely covers this entry.
	 */
	protected Rectangle2D.Double m_oldOutline = null;

	/**
	 * The outline rectangle that completely covers this entry.
	 */
	protected Rectangle2D.Double m_newOutline = null;

	/**
	 * The width of the <code>Tk_ChartEntry</code>.
	 */
	protected long m_width				= 0;
	
	/**
	 * The height of the <code>Tk_ChartEntry</code>.
	 */
	protected long m_height 			= 0;
	
	/**
	 * The initial width of the <code>Tk_ChartEntry</code>.
	 */
	private long m_initialWidth			= 0;

	/**
	 * The initial height of the <code>Tk_ChartEntry</code>.
	 */
	private long m_initialHeight 		= 0;

	/**
	 * Colours for the bars on this graph. 
	 */
	private Color[] m_colours = 
		{
			Color.blue,
			Color.magenta,
			Color.green,
			Color.red,
			Color.yellow,
			Color.cyan,
			Color.orange,
	        Color.pink,
	        Color.gray,
	        Color.darkGray,
	        Color.black,
	        Color.lightGray
	    };
	
	
	/**
	 * Record which colours have been used for each string.
	 */
	private static HashMap<String, Color>m_colourMap = null;

	/**
	 * An index into the colour table to allow selecting a colour for the next
	 * bar.
	 */
	private static int m_colourIndex 			= 0;
	
	protected Tk_BarChartEntry
	(
		Tk_GraphDirection 		dir,
		Graphics2D				canvas,
		Point2D.Double			origin,
		long					initial_width,
		long					initial_height,
		Tk_BarChartEntry		parent
	)
	{
		m_growDirection 	= dir;
		m_canvas 			= canvas;
		m_origin 			= origin;
		m_initialWidth		= initial_width;
		m_width				= initial_width;
		m_initialHeight		= initial_height;
		m_height			= initial_height;
		m_parent			= parent;
		m_oldOutline = new Rectangle2D.Double(m_origin.x, m_origin.y, m_width, m_height);
	}
	
	public static HashMap<String, Color>getColourMap()
	{
		return m_colourMap;
	}
	
	/**
	 * 
	 */
	/*
	public static void createLegend()
	{
		Iterator<String>col_it = m_colourMap.keySet().iterator();
		Vector<JPanel>legend_entries = new Vector<JPanel>();
		System.out.println("createLegend()");
		while (col_it.hasNext())
		{
			String next_task = col_it.next();
			System.out.printf("Creating entry for %s\n", next_task);
			legend_entries.add(createLegendEntry(next_task, m_colourMap.get(next_task)));
		}
		
		JFrame jf = new JFrame("Task/Colour Legend.");
		Iterator<JPanel>vit = legend_entries.iterator();
		while (vit.hasNext())
		{
			System.out.println("Adding a JPanel to the JFrame.");
			jf.add(vit.next());
		}
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		jf.setVisible(true);
	}
	
	public static JPanel createLegendEntry(String tname, Color col)
	{
		System.out.printf("createLegendEntry for string = %s and colour = %h\n", tname, col);
		JLabel nameLabel = new JLabel(tname);
		JLabel colorLabel = new JLabel();
		Graphics g = colorLabel.getGraphics();
		if (null == g)
		{
			System.out.println("Got null graphics object");
			System.exit(-1);
		}
		g.setColor(col);
		Rectangle r1 = new Rectangle(0,0,20,20);
		g.drawRect(r1.x, r1.y, r1.width, r1.height);
		colorLabel.setBackground(col);
		
		colorLabel.setMinimumSize(r1.getSize());
		colorLabel.setPreferredSize(r1.getSize());
		colorLabel.setMaximumSize(r1.getSize());
		colorLabel.setOpaque(true);
		colorLabel.setBounds(r1);
		Rectangle r2 = new Rectangle(0,0, 100, 20);
		nameLabel.setMinimumSize(r1.getSize());
		nameLabel.setMaximumSize(r2.getSize());
		nameLabel.setPreferredSize(r2.getSize());
		nameLabel.setBounds(r2);
		nameLabel.setText(tname);
		JPanel jp = new JPanel();
		Rectangle r3 = new Rectangle(0, 0, 130, 20);
		jp.setMinimumSize(r3.getSize());
		jp.setMaximumSize(r3.getSize());
		jp.setPreferredSize(r3.getSize());
		jp.setBounds(r3);
		jp.add(nameLabel);
		jp.add(colorLabel);
		JFrame jf = new JFrame(String.format("%s - %h", tname, col));
		jf.add(jp);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		jf.setVisible(true);
		return jp;
	}
*/
	public void paint(Graphics2D g2)
	{
		/*if (m_newOutline != null)
		{
			Color bg = g2.getBackground();
			Color fg = g2.getColor();
			//g2.setColor(Color.white);
			g2.setColor(bg);
			g2.fill(m_oldOutline);
			g2.setColor(fg);
			m_oldOutline = m_newOutline;
			m_newOutline = null;
		}*/
	}
	
	public void setNewOutline(Point2D.Double origin, long w, long h)
	{
		m_newOutline = new Rectangle2D.Double(origin.x, origin.y, w, h);
	}
	
	public Color getColour(String name)
	{
		if (m_colourMap == null)
		{
			m_colourMap = new HashMap<String, Color>();
		}
		
		if (!m_colourMap.containsKey(name))
		{
			Color c = m_colours[m_colourIndex];
			m_colourMap.put(name, c);
			m_colourIndex = (m_colourIndex + 1) % m_colours.length;
		}
		return m_colourMap.get(name);
	}

	public Tk_GraphDirection getGrowDirection()
	{
		return m_growDirection;
	}
	
	public Tk_BarChartEntry getParent()
	{
		return m_parent;
	}
	
	public Graphics2D getCanvas()
	{
		return m_canvas;
	}
	
	public Point2D.Double getOrigin()
	{
		return m_origin;
	}

	public long getWidth()
	{
		return m_width;
	}
	
	public abstract void setWidth(long new_width);
	public abstract void setHeight(long new_height);
	public abstract void setOrigin(Point2D.Double new_origin);
	public abstract void changeBar
		(long new_width, long new_height, Point2D.Double new_origin);

	public long getHeight()
	{
		return m_height;
	}
	
	public long getInitialWidth()
	{
		return m_initialWidth;
	}
	
	public long getInitialHeight()
	{
		return m_initialHeight;
	}
}package Tk_Gui;

import java.util.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.geom.Point2D.Double;

public class Tk_BarContainer extends Tk_BarChartEntry
{
	public static final double BarPart	= 0.8;
	public static final double GapPart	= 0.2;

	/**
	 * The children of this <code>Tk_ChartEntry</code>.
	 * Fixme: This should go in the Tk_BarContainer child. 
	 */
	private Vector<Tk_ChartEntry>m_children = null;
	
	private String m_catName				= null;
	
	/**
	 * 
	 */
	private long m_barWidth						= 0;
	
	private long m_barGap;
	/**
	 * 
	 * @param dir
	 * @param name
	 * @param canvas
	 * @param origin
	 * @param initial_width
	 * @param initial_height
	 * @param parent
	 */
	
	public Tk_BarContainer
	(
		Tk_GraphDirection 		dir,
		String					cat_name,
		String					name,
		Graphics2D				canvas,
		Point2D.Double			origin,
		long					initial_width,
		long					initial_height,
		Tk_BarChartEntry		parent
	)
	{
		super(dir, canvas, origin, initial_width, initial_height, parent);
		m_catName = cat_name;
		m_barWidth = (long)Math.ceil(0.8 * initial_width);
		m_barGap   = initial_width - m_barWidth;
		m_children = new Vector<Tk_ChartEntry>();
	}
	
	public void setChildProperties()
	{
		if (m_children.size() > 0)
		{
			System.out.println("setChildProperties():Have children.");
			long total_bar_width = (long)Math.ceil(0.8 * getWidth());
			System.out.printf("canTakeOneMore():TotalBarWidth is %d\n", total_bar_width);
			m_barWidth = (long)Math.floor(total_bar_width/(m_children.size() + 1));
			long total_bar_gap   = getWidth() - total_bar_width;
			m_barGap = (long)Math.floor(total_bar_gap/(m_children.size() + 1));
			System.out.printf("Tk_BarContainer.canTakeOneMore: Just set m_barWidth to %d\n", m_barWidth);
			System.out.printf("Tk_BarContainer.canTakeOneMore: Just set m_barGap to %d\n", m_barGap);
			System.out.printf("Total_bar_gap is %d\n", total_bar_gap);
		}
	}
	
	public boolean canTakeOneMore()
	{
		System.out.println("canTakeOneMore():Enter.");
		if (m_children.size() == 0)
		{
			System.out.println("canTakeOneMore():No children - returning true.");
			return true;
		}
		long total_bar_width = (long)Math.ceil(0.8 * getWidth());
		System.out.printf("canTakeOneMore():TotalBarWidth is %d\n", total_bar_width);
		m_barWidth = (long)Math.floor(total_bar_width/(m_children.size() + 1));
		long total_bar_gap   = getWidth() - total_bar_width;
		m_barGap = (long)Math.floor(total_bar_gap/(m_children.size() + 1));
		System.out.printf("Tk_BarContainer.canTakeOneMore: Just set m_barWidth to %d\n", m_barWidth);
		System.out.printf("Tk_BarContainer.canTakeOneMore: Just set m_barGap to %d\n", m_barGap);
		System.out.printf("Total_bar_gap is %d\n", total_bar_gap);
		if ((total_bar_width + total_bar_gap) < getMinimumWidth())
		{
			System.out.printf("Total_bar_gap + total bar width < %d\n", getMinimumWidth());
			return false;
		}
		long single_bar_width = (long)Math.ceil((double)total_bar_width/(m_children.size() + 1));
		
		System.out.printf("Tk_BarContainer.canTakeOneMore(): single_bar_width is %d and minWidth is %d\n",
					single_bar_width, m_children.get(0).getMinimumWidth());
		if (single_bar_width < m_children.get(0).getMinimumWidth())
		{
			return false;
		}
		return true;
	}
	
	public void addBarElement(String name, long h)
	{
		//boolean bar_ok = getNewBarWidth();
		System.out.printf("Tk_BarContainer.addBarElement: m_barWidth is %d m_barGap is %d\n",
				m_barWidth, m_barGap);
		long origin_x = (long)getOrigin().x + m_barGap/2;
		for (int i = 0; i < m_children.size(); i++)
		{
			System.out.printf("Tk_BarContainer.addBarElement(): Setting new child x origin at %d\n", origin_x);
			Point2D.Double new_origin = new Point2D.Double(origin_x, m_origin.y);
			Tk_BarChartEntry tbc = (Tk_BarChartEntry)m_children.get(i); 
			tbc.changeBar(m_barWidth, tbc.getHeight(), new_origin);
			origin_x +=  (m_barWidth + m_barGap);
		}

		System.out.printf("Tk_BarContainer.addBarElement(): adding brand new bar at x = %d\n",
				origin_x);
		Tk_Bar tb =
			new Tk_Bar
			(
				getGrowDirection(),
				name,
				getCanvas(),
				new Point2D.Double(origin_x, m_origin.y),
				m_barWidth,
				h,
				this
			);
		addChild(tb);
	}
	
	private void addChild(Tk_BarChartEntry tbc)
	{
		m_children.add(tbc);
	}

	@Override
	public long getMinimumWidth()
	{
		// assume all children have the same width properties, and return
		// the width as (1 / BarPart) * minimum width of all children.
		long min_child_width = m_children.size() > 0 ?
				m_children.get(0).getMinimumWidth() : 0;
		long bar_container_min =
				(long)Math.floor(((m_children.size() + 1) * min_child_width)/BarPart);
		return bar_container_min;
	}
	
	@Override
	public long getPreferredWidth()
	{
		// assume all children have the same width properties, and return
		// the width as (1 / BarPart) * preferred width of all children.
		long pref_child_width = m_children.size() > 0 ?
				m_children.get(0).getPreferredWidth() : 0;
		long bar_container_pref =
				(long)Math.floor((m_children.size() * pref_child_width)/BarPart);
		return bar_container_pref;
	}

	@Override
	public long getMaximumWidth()
	{
		// assume all children have the same width properties, and return
		// the width as (1 / BarPart) * maximum width of all children.
		long max_child_width = m_children.size() > 0 ?
				m_children.get(0).getMaximumWidth() : 0;
		long bar_container_max =
				(long)Math.floor((m_children.size() * max_child_width)/BarPart);
		return bar_container_max;
	}

	
	@Override
	public void paint(Graphics2D g2)
	{
		super.paint(g2);
		Iterator<Tk_ChartEntry> it = m_children.iterator();
		while (it.hasNext())
		{
			it.next().paint(g2);
		}

	}

	@Override
	public void setWidth(long new_width)
	{
		m_width = new_width;
	}

	@Override
	public void setHeight(long new_height)
	{
		m_height = new_height;
	}

	@Override
	public void setOrigin(Point2D.Double new_origin)
	{
		m_origin = new_origin;
	}

	@Override
	public void changeBar(long new_width, long new_height, Point2D.Double new_origin)
	{
		System.out.printf("In TkBarContainer.changeBar for bar = %s\n", m_catName);
		System.out.printf("Current bar is %s width(%d) and height(%d)\n",
				m_origin.toString(), getWidth(), getHeight());
		System.out.printf("Changing bar to %s with width(%d) and height(%d)\n",
				new_origin.toString(), new_width, new_height);
		setWidth(new_width);

		m_barWidth = (long)Math.ceil(0.8 * getWidth()/(m_children.size() + 1));
		m_barGap = (long)Math.floor(0.2 * getWidth()/(m_children.size() + 1));
		System.out.printf("Tk_BarContainer.changeBar: New m_barWidth = %d\n", m_barWidth);
		System.out.printf("Tk_BarContainer.changeBar: New m_barGap = %d\n", m_barGap);

		setHeight(new_height);
		setOrigin(new_origin);
		setNewOutline(m_origin, new_width, new_height);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}



}
package Tk_Gui;
import Tk_utils.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.geom.Point2D.Double;
import java.awt.font.*;
import javax.xml.datatype.*;
import javax.swing.*;

import java.lang.Math;
import java.util.*;

public class Tk_BarGraph<T> extends Tk_Graph<T>
{
	
	private Vector<String> 			m_categories 		= null;
	private Vector<GlyphVector>		m_xGlyphs			= null;
	private Font 					m_xLabelFont			= null;
	
	private long m_entryWidth							= 0;

	public Tk_BarGraph
	(
		Tk_GraphDirection gd,
		long height_on_screen,
		long start_range,
		long end_range,
		long width_on_screen,
		Vector<String>x_categories,
		long big_y_ticks,
		long small_y_ticks,
		String x_label,
		String y_label,
		Tk_Converter<T, Long> converter,
		long graph_entry_width
	)
	{
		super
		(
			gd,
			height_on_screen,
			start_range,
			end_range,
			width_on_screen,
			0,
			x_categories.size() * graph_entry_width,
			big_y_ticks,
			small_y_ticks,
			x_categories.size(),
			0,
			x_label,
			y_label,
			converter
		);
		m_categories = x_categories;
		m_entryWidth = graph_entry_width;
		createXAxis();
	}
	
	/**
	 * Paint the graph, including any <code>Tk_ChartEntry</code>s that belong
	 * on the graph.
	 */
	public void paintComponent(Graphics g)
    {
		//System.out.println("In paintComponent!");
    	super.paintComponent(g);
    	Graphics2D g2 = (Graphics2D)g;

    	// If the font is null, create it and the glyph vectors for labelling
    	// the x and y axes.
    	if (null == m_xLabelFont)
    	{
    		m_xLabelFont = new Font("Serif", Font.BOLD, (int)Math.min(getHeightBuffer()/2, getWidthBuffer()/2));
    		m_xGlyphs = new Vector<GlyphVector>();
    		g2.setFont(m_xLabelFont);
    		AffineTransform at = null;
    		String longest_string = null;
    		Rectangle2D longest_rect = null;
    		for (int i = 0; i < m_categories.size(); i++)
    		{
    			String next_label = m_categories.get(i);
    			Rectangle2D string_rec = m_xLabelFont.getStringBounds(next_label, g2.getFontRenderContext());
    			if (longest_rect == null)
    			{
    				longest_rect = string_rec;
    				longest_string = next_label;
    			}
    			else if (longest_rect.getWidth() < string_rec.getWidth())
    			{
    				longest_rect = string_rec;
    				longest_string = next_label;
    			}
    		}
    		double x_scale = 0.7 * m_entryWidth / longest_rect.getWidth();
    		at = AffineTransform.getScaleInstance(x_scale, x_scale);
    		Font scaled_font = m_xLabelFont.deriveFont(at);
    		for (int i = 0; i < m_categories.size(); i++)
    		{
    			String next_label = m_categories.get(i);
    			m_xGlyphs.add
    			(
    				i,
					scaled_font.createGlyphVector(g2.getFontRenderContext(), next_label)
    			);
    		}
    	}

    	for (int i = 0; i < m_xGlyphs.size(); i++)
    	{
    		long next_pos = i * m_entryWidth + m_entryWidth / 2;
    		GlyphVector gv = m_xGlyphs.get(i);
    		Shape s = gv.getOutline();
    		g2.drawGlyphVector
    		(
    			gv,
    			next_pos + getWidthBuffer() - s.getBounds().width/2,
    			getComponentHeight() - getHeightBuffer()/2
    		);
    	}
    }
	

	@Override
	public void createXAxis()
	{
		System.out.println("Tk_BarGraph:In createXAxis");
		System.out.printf("Tk_BarGraph:createXAxis() - getEntryWidth() == %d\n", getEntryWidth());
		System.out.printf("Tk_BarGraph:createXAxis() - getWidthBuffer() == %d\n", getWidthBuffer());
		super.createXAxis();
		long x_val = getEntryWidth();
		System.out.println("Tk_BarGraph:createXAxis - clearing m_smallXTicksPath");
		m_smallXTicksPath.reset();
		while (x_val <= getEndDomain() - getStartDomain())
		{
			//long x_convert = convertXVal(x_val);
			System.out.printf("Tk_BarGraph.creatXAxis(): adding tick at x = %d\n", getWidthBuffer() + x_val);
			m_smallXTicksPath.moveTo(getWidthBuffer() + x_val, 11 * getHeightBuffer());		//  + x_convert
			m_smallXTicksPath.lineTo(getWidthBuffer() + x_val, 11.2 * getHeightBuffer());	//  + x_convert
			x_val+= getEntryWidth();
		}
	}

	/**
	 * Add a <code>Tk_BarContainer</code>  for category <code>cat_name</code>
	 * if there isn't already on in the graph, and add the new Bar with name
	 * <code>bar_name</code> to it. The newly added <code>Tk_BarContainer</code>
	 * is a container for the graph's bars for the givent category name.
	 * Having added the new bar container element to the graph, subsequent
	 * calls to this method for the same String <code>cat_name</code> will
	 * simply add another bar to the <code>Tk_BarContainer</code> element.
	 *
	 * @param cat_name	The name of the category (on the x-axis) where the
	 *                  new bar, and hence the new bar container should appear.
	 * @param bar_name	The name of the new bar - for example a task name.
	 * @param x_origin	The position of the bottom left corner of the new
	 * 					bar container if one needs to be created.
	 * @param h			The height of the graph component, and therefore the
	 * 					height of the bar container, and the maximum height of
	 * 					a bar within that container.
	 */
	public void addBarElement(String cat_name, String bar_name, long x_origin, long h)
	{
		Tk_BarContainer tkb = null;
		if (!hasElement(cat_name))
		{
			tkb = 
				new Tk_BarContainer
				(
					getGrowDirection(),
					cat_name,
					cat_name,
					(Graphics2D)getGraphics(),
					new Point2D.Double(x_origin, getComponentHeight() - getHeightBuffer()),
					m_entryWidth,
					getGraphHeight(),
					null
				);
			addElement(cat_name, tkb);
			if (m_entryWidth * m_entries.size() > m_widthOnScreen)
			{
				m_widthOnScreen = m_entryWidth * m_entries.size();
				this.setDimensions();
				createXAxis();
			}
		}
		else
		{
			tkb = (Tk_BarContainer)getElement(cat_name); 
		}
		//
		// Fixme: what about making Tk_CharEntry.addBarElement() return a boolean
		// that indicates whether or not the new bar will fit. This would be if the
		// newly calculated width of each bar went below a predetermined minimum.
		//
		if (!tkb.canTakeOneMore())
		{
			System.out.println("Tk_BarGraph.addBarElement: Can't take one more.");
			System.out.printf("Old m_EntryWidth is %d\n", m_entryWidth);
			m_entryWidth = tkb.getMinimumWidth();
			System.out.printf("New m_EntryWidth is %d\n", m_entryWidth);
			m_endDomain = m_entryWidth * m_categories.size();//m_widthOnScreen;
			m_widthOnScreen = (long)1.2 * m_endDomain; //m_entryWidth * m_categories.size();
			System.out.printf("Width On Screen is %d\n", m_widthOnScreen);
			setDimensions();
			//setWidth(1.2 * m_widthOnScreen);
			createXAxis();
			Iterator<String>sit = m_entries.keySet().iterator();
			x_origin = 0;
			while (sit.hasNext())
			{
				Tk_BarChartEntry tbc = (Tk_BarChartEntry)m_entries.get(sit.next());
				tbc.changeBar
				(
					m_entryWidth, 
					tbc.getHeight(),
					new Point2D.Double
					(
						getWidthBuffer() + x_origin,
						getComponentHeight() - getHeightBuffer()
					)
				);
				x_origin += m_entryWidth;
			}
		}
		// add the bar.
		tkb.addBarElement(bar_name, convertYVal(h));
		repaint();
	}
	
	public long getEntryWidth()
	{
		return m_entryWidth;
	}

	@Override
	public int getScrollableUnitIncrement
	(
		Rectangle visibleRect,
		int orientation,
		int direction
	)
	{
		if (orientation == SwingConstants.HORIZONTAL)
		{
			return (int)getEntryWidth()/4;
		}
		else
		{
			return (int)getComponentHeight()/20;
		}
	}
	
	@Override
	public int getScrollableBlockIncrement
	(
		Rectangle visibleRect,
		int orientation,
		int direction
	)
	{
		return 2 * getScrollableUnitIncrement(visibleRect, orientation, direction);
	}

	public static void drawBarGraph()
	{
		String test_data[] =
			{
				"Monday",
				"Tuesday",
				"Wednesday",
				"Thursday",
				"Friday",
				"Saturday",
				"Sunday"
			};
				/*,
				"Jan",
				"Feb",
				"Mar",
				"May",
				"Jun",
				"Jul",
				"Aug",
				"Sept",
				"Oct",
				"Nov",
				"Dec",
				"One",
				"Two",
				"Three",
				"Four",
				"Five",
				"Six",
				"Seven",
				"Eight",
				"Nine",
				"zero"
			};*/
		Vector<String>vs = new Vector<String>();
		for (int i = 0; i < test_data.length; i++)
		{
			vs.add(test_data[i]);
		}
		Tk_BarGraph<Duration> tkb =
			new Tk_BarGraph<Duration>
			(
				Tk_GraphDirection.LeftToRight,
				400,	// height on screen.
				0,		// start range
				1000,	// end range
				400,	// width on screen
				vs,
				100,	// big y ticks
				10,		// small y ticks.
				"X Label",
				"Y Label",
				(Tk_Converter)(new Tk_LongLong()),
				200
			);
		int num_bars = 0;
		for (int i = 0; i < vs.size(); i++)
		{
			//int bar_num = 1 + (int)Math.ceil(15 * Math.random());
			int bar_num = 5;
			System.out.printf("Putting %d bars in cat %d\n", bar_num, i);
			for (int j = 0; j < bar_num; j++)
			{
				System.out.printf("Adding bar %d\n", j);
				long h = (long)Math.ceil(1000 * Math.random());
				//String bar_name = String.format("%s:%s:%d", vs.get(i), "bar", j);
				tkb.addBarElement(vs.get(i), vs.get(i), tkb.getWidthBuffer() + i * tkb.m_entryWidth, h);
			}
			num_bars += bar_num;
		}
		System.out.printf("Number of Bars is %d\n", num_bars);
		System.out.printf("The width of the graph is: %d \n", tkb.getWidth());
		//tkb.createGraph();
		System.out.printf("The width of the graph is: %d \n", tkb.getWidth());
		JFrame jf = new JFrame();
		JScrollPane jsc = new JScrollPane(tkb);
		jsc.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);
		jsc.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		jsc.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
		//jsc.add(tkb);
		jf.setUndecorated(false); //true);
		System.out.printf("jsc.getViewPort().getSize() is %s\n", jsc.getViewport().getSize().toString());
		//jf.setSize(jsc.getSize());
		//jf.setBackground(new Color(255, 255, 255, 0));
		jf.add(jsc);
		System.out.printf("jsc.getSize() is %s\n", jsc.getViewport().getSize().toString());
		//Tk_MouseListener tml = new Tk_MouseListener(jf);
		//jf.addMouseListener(tml);		
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
		JFrame jf_legend = new JFrame("Graph Legend");
		Tk_GraphLegend tgl = new Tk_GraphLegend(new Rectangle(0,0,200,200));
		jf_legend.add(tgl);
		jf_legend.pack();
		jf_legend.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		jf_legend.setVisible(true);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		SwingUtilities.invokeLater
		(
			new Runnable()
			{
				public void run()
				{
					drawBarGraph();
				}
			}
		);
	}

}
package Tk_Gui;

import java.awt.*;
public interface Tk_ChartEntry
{
	public void paint(Graphics2D g2);

	/**
	 * Get the minimum width of this component.
	 *
	 * @return The minimum width this component can occupy.
	 */
	public long getMinimumWidth();
	
	/**
	 * Get the preferred width of this component.
	 *
	 * @return The preferred width for this component to occupy.
	 */
	public long getPreferredWidth();
	
	/**
	 * Get the maximum width of this component.
	 *
	 * @return The maximum width this component can occupy.
	 */
	public long getMaximumWidth();

}
package Tk_Gui;

import java.util.*;
import org.w3c.dom.*;
import javax.xml.datatype.*;

import Tk_History.Tk_ActiveTimeRecord;

/**
 * Abstract Clock class. The idea being that it can be instantiated as either a
 * digital or analog clock.
 * 
 * Note: At present we only have the Tk_Digital version.
 *  
 * @author michaelwebster
 */
public abstract class Tk_Clock implements Observer
{
	/**
	 * A map from task names to lists of xml time record Documents..
	 */
	private HashMap<String, Vector<Document>>m_elMap = 
			new HashMap<String, Vector<Document>>();
	
	/**
	 * The name of the current task being timed.
	 */
	private String m_currentTaskName	= null;

	/**
	 * An active time record that keeps track of the time, and can serialize
	 * its time records.
	 */
	protected Tk_ActiveTimeRecord m_tr;
	
	/**
	 * The <code>Duration</code> that records how much time has been spent on
	 * the task across possibly multiple starts and stops of the task.
	 */
	private Duration m_totalDuration		= null;
	
	/**
	 * Periodic update caused by a timer tick. 
	 */
	public abstract void updateDisplay();

	/**
	 * Set the total duration for a newly started task.
	 */
	protected void setTotalDuration()
	{
		if (m_totalDuration == null)
		{
			m_totalDuration = m_tr.getCurrentDuration();
		}
	}
	
	/**
	 * Set the total duration for a newly started task from the supplied
	 * duration value.
	 *
	 * @param d 	The <code>Duration</code> value to be set as total duration
	 * 				for this task. 
	 */
	protected void setTotalDuration(Duration d)
	{
		m_totalDuration = d;
	}
	
	/**
	 * Return the total duration for this task.
	 *
	 * @return		The total <code>Duration</code> this task has been running
	 * 				since the last task switch. 
	 */
	protected Duration getTotalDuration()
	{
		return m_totalDuration;
	}
	
	/**
	 * Return a <code>String</code> representation of the start time of this
	 * task.
	 *
	 * @return		A string representing the start time of this task.
	 */
	protected String getStartTimeString()
	{
		return m_tr.getStartTime();
	}
	
	/**
	 * Return a <code>String</code> representation of the end time of this
	 * task.
	 *
	 * @return		A string representing the end time of this task.
	 */
	protected String getEndTimeString()
	{
		return m_tr.getEndTime();
	}
	
	/**
 	 * Return a <code>String</code> representation of the
 	 * <code>Duration</code> through which this task has been running.
	 *
	 * @return		A string representing the elapsed time of this task.
	 */
	protected String getDurationString()
	{
		return m_tr.getDuration();
	}
	
	/**
 	 * Return a <code>Duration</code> representation of the elapsed time this
	 * task has been running.
	 *
	 * @return		A duration representing the elapsed time of this task.
	 */
	protected Duration getDuration()
	{
		return m_tr.getCurrentDuration();
	}
	
	/**
	 * Start the clock on this task.
	 */
	protected void startTask()
	{
		m_tr.startTask();
	}
	
	/**
	 * Stop the clock on this task.
	 */
	protected void stopTask()
	{
		m_tr.stopTask();
	}
	
	/**
	 * Return a DOM document representation of the current task's time
	 * record.
	 *
	 * @return		A <code>Document</code> that encodes the current time
	 * 				record.
	 */
	Document getXMLTimeRecord()
	{
		return m_tr.getXMLDocument();
	}
	
	/**
	 * Add <code>Duration</code> cur_dur to <code>m_totalDuration</code> and
	 * return the result <code>Duration</code>.
	 *
	 * @param cur_dur	A <code>Duration</code> to be added to the
	 * 					<code>m_totalDuration>.
	 *
	 * @return			The <code>Duration</code> that is the sum of cur_dur
	 * 					and <code>m_totalDuration</code>.
	 */
	protected Duration addDuration(Duration cur_dur)
	{
		int tot_secs = cur_dur.getSeconds() + m_totalDuration.getSeconds();
		int tot_mins = cur_dur.getMinutes() + m_totalDuration.getMinutes();
		int tot_hours = cur_dur.getHours() + m_totalDuration.getHours();
		
		int final_secs =  tot_secs % 60;
		int extra_min = tot_secs / 60;
		int tm = tot_mins + extra_min;
		int final_mins = tm % 60;
		int extra_hour = tm / 60;
		int final_hours = tot_hours + extra_hour;
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord(long, long, long) constructor."
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}
		Duration d = dtf.newDuration(true, 0, 0, 0, final_hours, final_mins, final_secs);
		return d;
	}

	/**
	 * Set the current task name.
	 *
	 * @param tname		The name of a task to be timed.
	 */
	protected void setCurrentTaskName(String tname)
	{
		m_currentTaskName = tname;
	}
	
	/**
	 * Return the name of the current task.
	 *
	 * @return		The name of the current task.
	 */
	protected String getCurrentTaskName()
	{
		return m_currentTaskName;
	}
	
	/**
	 * Return the m_alMap mapping between task names and lists of documents
	 * that is maintained by this clock.
	 *
	 * @return		A <code>HashMap</code> containing a mapping between tasks
	 * 				and <code>Vector</code>s of documents.
	 */
	public HashMap<String, Vector<Document>>getTaskMap()
	{
		return m_elMap;
	}

	/**
	 * Add a new task name <code>Vector<Document></code> pair to the clock's
	 * map.
	 *
	 * @param tname		The name of a task.
	 * @param vd		A <code>Vector</code> of <code>Document</code>s.
	 */
	protected void putMap(String tname, Vector<Document>vd)
	{
		m_elMap.put(tname, vd);
	}
	
	/**
	 * Return the <code>Vector<Document></code> stored with key = key in this
	 * clock's mapping from tasknames to lists of documents.
	 *
	 * @param key		The name of the task we want to get the 
	 * 					<code>Vector</code> of <code>Document</code>s for.
	 *
	 * @return			A <code>Vector</code> containing <code>Document</code>s.
	 */
	protected Vector<Document>getEl(String key)
	{
		return m_elMap.get(key);
	}

	/**
	 * Create a new Tk_ActiveTime Record for this clock, initialised to the
	 * current time. Add an observer to the clock so that we can update the
	 * current time, the duration, and the total duration strings, when the
	 * active time record ticks.
	 */
	protected void setUpClock()
	{
		Date d = new Date();
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTime(d);
		m_tr = new Tk_ActiveTimeRecord(gc.getTimeInMillis());
		m_tr.addObserver(this);
	}

	/**
	 * Test if the clock is running - ie. the clock's active time record's
	 * timer is going.
	 *
	 * @return	true => The active time record's timer is running.
	 * 			false => otherwise.
	 */
	public boolean isActive()
	{
		return m_tr.getTimer().isRunning();
	}

	/**
	 * Update displays for the current time, duration and total duration
	 * fields when the active time record notifies of a timer tick.
	 */
	public void update(Observable tatr, Object o)
	{
		if (tatr == m_tr)
		{
			// We've got the right clock.
			updateDisplay();
		}
	}
	
	public void startClock()
	{
		startTask();

	}

	/**
	 * Stop the <code>Tk_ActiveTimeRecord m_tr</code> task timer, and update
	 * the <code>m_totalDuration</code> field. Get an xml Document
	 * serialization of the <code>Tk_ActiveTimeRecord m_tr</code> store it
	 * and then setup the clock for the next time recording. 
	 * 
	 */
	public void stopClock()
	{
		stopTask();
		setTotalDuration(addDuration(getDuration()));
		Document time_record = getXMLTimeRecord();
		
		Vector<Document>vn = null;
		if (!getTaskMap().containsKey(getCurrentTaskName()))
		{
			vn = new Vector<Document>();
			putMap(getCurrentTaskName(), vn);
		}
		else
		{
			vn = getEl(getCurrentTaskName());
		}
		vn.add(time_record);
		setUpClock();
	}
	
	/**
	 * Switch to a new task by creating and setting up the title border with
	 * the new task name, and initializing the <code>m_totalDuration</code>
	 * field.
	 * 
	 * @param new_task		The name of the task to switch to.
	 */
	public void switchTasks(String new_task)
	{
		setCurrentTaskName(new_task);
		setTotalDuration(getDuration());
	}
}
/**
 * Manages data for the Tk_Gui's JComboBox.
 */
package Tk_Gui;

import java.util.Vector;
import javax.swing.DefaultComboBoxModel;

/**
 * @author michaelwebster
 *
 */
public class Tk_ComboBoxModel extends DefaultComboBoxModel {

	/*public TkComboBoxModel()*/
	/**
	 * Ban the use of this constructor.
	 */
	private Tk_ComboBoxModel() {
		super();
	}

	/**
	 * Ban the use of this contructor by making it private.
	 *
	 * @param items 	A list of elements for the combo box.
	 */
	private Tk_ComboBoxModel(Object[] items) {
		super(items);
	}

	/**
	 * Ban the use of this constructor by making it private.
	 *
	 * @param v A vector of elements for the list in the combo box.
	 */
	private Tk_ComboBoxModel(Vector v) {
		super(v);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
package Tk_Gui;

import java.awt.*;
//import java.awt.font.*;
import java.awt.geom.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.BevelBorder;
import org.w3c.dom.*;
import javax.xml.datatype.*;

/**
 * <p>Tk_Digital provides a display for a running task clock. It displays the
 * start time for a task, the current time, and a Duration value that
 * represents the difference between the current time and the start time.
 * It also displays a TotalDuration field that displays the Total time
 * spent on this task which will be different to the Duration if the task
 * has been stopped and started again.</p>
 * 
 * <p>The class uses a <code><a href="../Tk_History/Tk_ActiveTimeRecord.html">Tk_ActiveTimeRecord</a></code>
 * to keep track of the time, and updates the time fields in response to
 * updates received from the <code>Tk_ActiverTimeRecord</code>.</p>
 * 
 * <p>When a task is stopped, a DOM Document representation of that task's time
 * record is obtained from the <code>Tk_ActiveTimer</code>, and placed in the
 * <code>m_elMap</code> HashMap.</p>
 * 
 * @author michaelwebster
 */
public class Tk_Digital extends Tk_Clock
{
	/**
	 * The Label for the start time field.
	 */
	private final static String StartTimeString		=
			String.format("Start Time: ");
	/**
	 * The label for the current time field.
	 */
	private final static String CurrentTimeString	=
			String.format("Current Time: ");

	/**
	 * The label for the duration field. 
	 */
	private final static String DurationString		=
			String.format("Duration: ");

	/**
	 * The Label for the Total Duration field. 
	 */
	private final static String TotalDurationString	=
			String.format("Total Duration: ");
	
	/**
	 * A prototype value for setting the size of the Time and duration fields.
	 */
	private final static String TimePrototype = 
			"Wed Dec 11 13:03:03 EST 2013----";

	/**
	 * Prefix for the title of the Border around the <code>Tk_Digital</code>
	 * display.
	 */
	private final static String TaskPrefix = "Task: ";

	/**
	 * A Box to hold the <code>Tk_Digital</code> time display labels.
	 */
	private Box m_box					= null;

	/**
	 * The string containing the time the task was started.
	 */
	private String m_startString		= null;
	
	/**
	 * The label for the tasks start time field.
	 */
	private JLabel m_startLabel			= null;
	
	/**
	 * The label containing the actual time the task was started at.
	 */
	private JLabel m_startTimeLabel		= null;
	
	/**
	 * The string containing the current time.
	 */
	private String m_currentString		= null;
	
	/**
	 * The label for the tasks current time field.
	 */
	private JLabel m_currentLabel		= null;
	
	/**
	 * The label containing the actual current time.
	 */
	private JLabel m_currentTimeLabel	= null;
	
	/**
	 * The string containing the duration since the task was last started.
	 */
	private String m_durationString		= null;
	
	/**
	 * The label for the tasks duration field.
	 */
	private JLabel m_durationLabel		= null;
	
	/**
	 * The label containing the actual duration of the task since it was last
	 * started.
	 */
	private JLabel m_durationTimeLabel	= null;
	
	/**
	 * The string containing the total time the task has been running.
	 */
	private String m_totalDurationString	= null;
	
	/**
	 * The label for the tasks Total Duration field.
	 */
	private JLabel m_totalDurationLabel		= null;
	
	/**
	 * The label containing the actual total duration across starts and stops,
	 * that this task has been running.
	 */
	private JLabel m_totalDurationTimeLabel	= null;
	
	/**
	 * Creat a <code>Tk_Digital</code> clock with the supplied task_name as
	 * its border label.
	 * 
	 * @param task_name		The name of the task being timed.
	 */
	public Tk_Digital(String task_name)
	{
		setCurrentTaskName(task_name);
		setUpClock();
		setStartTimeDisplay();
		setCurrentTimeDisplay();
		setDurationDisplay();
		setTotalDurationDisplay();
		Font lfont = setupTitleLabels();
		setupTimeLabels(lfont);
		JPanel startPanel = new JPanel();
		startPanel.add(m_startLabel);
		startPanel.add(m_startTimeLabel);
		JPanel currentPanel = new JPanel();
		currentPanel.add(m_currentLabel);
		currentPanel.add(m_currentTimeLabel);
		JPanel durationPanel = new JPanel();
		durationPanel.add(m_durationLabel);
		durationPanel.add(m_durationTimeLabel);
		JPanel totalDurationPanel = new JPanel();
		totalDurationPanel.add(m_totalDurationLabel);
		totalDurationPanel.add(m_totalDurationTimeLabel);
		m_box = new Box(BoxLayout.PAGE_AXIS);
		m_box.add(startPanel);		
		m_box.add(currentPanel);
		m_box.add(durationPanel);
		m_box.add(totalDurationPanel);
		m_box.setBorder
		(
			BorderFactory.createTitledBorder
			(
				BorderFactory.createBevelBorder(BevelBorder.LOWERED),
				TaskPrefix + getCurrentTaskName()
			)
		);
	}

	/**
	 * Set up the labels that label each of the time and duration fields.
	 * Return the font we are using, so that it can be used in the actual time
	 * and duration fields.
	 *
	 * @return 	The font we have used in these labels.
	 */
	private Font setupTitleLabels()
	{
		m_startLabel 	= new JLabel();
		Graphics g = m_startLabel.getGraphics();
		Font fold = m_startLabel.getFont();
		float size = fold.getSize2D();
		Font fnew = fold.deriveFont(Font.BOLD, (float)1.5 * size);
		m_startLabel.setFont(fnew);
		FontMetrics fm = m_startLabel.getFontMetrics(fnew);
		Rectangle2D r2 = fm.getStringBounds(TotalDurationString, g);
		Dimension d = new Dimension
			(
				Math.round((float)r2.getWidth()),
				Math.round((float)r2.getHeight())
			);
		m_startLabel.setMaximumSize(d);
		m_startLabel.setMinimumSize(d);
		m_startLabel.setPreferredSize(d);
		m_startLabel.setBounds(r2.getBounds());
		m_startLabel.setText(StartTimeString);
		m_startLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_startLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_startLabel.setOpaque(true);
		m_startLabel.setBackground(Color.white);
		m_currentLabel 	= new JLabel(); //CurrentTimeString + m_currentString, SwingConstants.LEFT);
		m_currentLabel.setFont(fnew);
		m_currentLabel.setMaximumSize(d);
		m_currentLabel.setMinimumSize(d);
		m_currentLabel.setPreferredSize(d);
		m_currentLabel.setBounds(r2.getBounds());
		m_currentLabel.setText(CurrentTimeString);
		m_currentLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_currentLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_currentLabel.setOpaque(true);
		m_currentLabel.setBackground(Color.white);
		m_durationLabel = new JLabel();
		m_durationLabel.setFont(fnew);
		m_durationLabel.setMaximumSize(d);
		m_durationLabel.setMinimumSize(d);
		m_durationLabel.setPreferredSize(d);
		m_durationLabel.setBounds(r2.getBounds());
		m_durationLabel.setText(DurationString);
		m_durationLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_durationLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_durationLabel.setOpaque(true);
		m_durationLabel.setBackground(Color.white);

		m_totalDurationLabel = new JLabel();
		m_totalDurationLabel.setFont(fnew);
		m_totalDurationLabel.setMaximumSize(d);
		m_totalDurationLabel.setMinimumSize(d);
		m_totalDurationLabel.setPreferredSize(d);
		m_totalDurationLabel.setBounds(r2.getBounds());
		m_totalDurationLabel.setText(TotalDurationString);
		m_totalDurationLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_totalDurationLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_totalDurationLabel.setOpaque(true);
		m_totalDurationLabel.setBackground(Color.white);		
		return fnew;
	}

	/**
	 * Setup the actual time and duration labels using the supplied font.
	 *
	 * @param f		The font that the <code>JLabel</code>s are to use.
	 */
	private void setupTimeLabels(Font f)
	{
		// Setup the start time field.
		Font fnew = f.deriveFont(Font.PLAIN, f.getSize());
		m_startTimeLabel = new JLabel();
		m_startTimeLabel.setFont(fnew);
		Graphics g = m_startTimeLabel.getGraphics();
		FontMetrics fm = m_startTimeLabel.getFontMetrics(f);
		Rectangle2D r2 = fm.getStringBounds(TimePrototype, g);
		Dimension d = new Dimension
			(
				Math.round((float)r2.getWidth()),
				Math.round((float)r2.getHeight())
			);
		m_startTimeLabel.setMaximumSize(d);
		m_startTimeLabel.setMinimumSize(d);
		m_startTimeLabel.setPreferredSize(d);
		m_startTimeLabel.setBounds(r2.getBounds());
		m_startTimeLabel.setText(m_startString);
		m_startTimeLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_startTimeLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_startTimeLabel.setOpaque(true);
		m_startTimeLabel.setBackground(Color.white);
		
		// Setup the update time field.		
		m_currentTimeLabel 	= new JLabel();
		m_currentTimeLabel.setFont(fnew);
		m_currentTimeLabel.setMaximumSize(d);
		m_currentTimeLabel.setMinimumSize(d);
		m_currentTimeLabel.setPreferredSize(d);
		m_currentTimeLabel.setBounds(r2.getBounds());
		m_currentTimeLabel.setText(m_currentString);
		m_currentTimeLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_currentTimeLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_currentTimeLabel.setOpaque(true);
		m_currentTimeLabel.setBackground(Color.white);
		
		// Setup the duration field.
		m_durationTimeLabel 	= new JLabel();
		m_durationTimeLabel.setFont(fnew);
		m_durationTimeLabel.setMaximumSize(d);
		m_durationTimeLabel.setMinimumSize(d);
		m_durationTimeLabel.setPreferredSize(d);
		m_durationTimeLabel.setBounds(r2.getBounds());
		m_durationTimeLabel.setText(m_durationString);
		m_durationTimeLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_durationTimeLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_durationTimeLabel.setOpaque(true);
		m_durationTimeLabel.setBackground(Color.white);
		
		// Setup the total duration field.
		m_totalDurationTimeLabel 	= new JLabel();
		m_totalDurationTimeLabel.setFont(fnew);
		m_totalDurationTimeLabel.setMaximumSize(d);
		m_totalDurationTimeLabel.setMinimumSize(d);
		m_totalDurationTimeLabel.setPreferredSize(d);
		m_totalDurationTimeLabel.setBounds(r2.getBounds());
		m_totalDurationTimeLabel.setText(m_totalDurationString);
		m_totalDurationTimeLabel.setHorizontalAlignment(SwingConstants.LEFT);
		m_totalDurationTimeLabel.setVerticalAlignment(SwingConstants.CENTER);
		m_totalDurationTimeLabel.setOpaque(true);
		m_totalDurationTimeLabel.setBackground(Color.white);
	}

	/**
	 * Set the start time string to the start time obtained from the active
	 * Time record.
	 */
	public void setStartTimeDisplay()
	{
		m_startString = getStartTimeString();
	}

	/**
	 * Set the current time string to the end time obtained from the
	 * active time record.
	 */
	public void setCurrentTimeDisplay()
	{
		m_currentString = getEndTimeString();
	}

	/**
	 * Set the duration string to the value obtaines from the active time
	 * record.
	 */
	public void setDurationDisplay()
	{
		m_durationString = getDurationString();
	}
	
	/**
	 * Set the total duration display: <code>m_totalDurationString</code>,
	 * by creating a string from the addition of the existing total duration
	 * and the current duration.
	 */
	public void setTotalDurationDisplay()
	{
		setTotalDuration();
		Duration d = addDuration(getDuration());
		m_totalDurationString = getTotalDurationString(d); 
	}

	/**
	 * Return a formatted string representing the current duration.
	 *
	 * @return	A formatted string containing the current duration.
	 */
	public String getTotalDurationString()
	{
		String dur = String.format
				(
					"%02d:%02d:%02d",
					getTotalDuration().getHours(),
					getTotalDuration().getMinutes(),
					getTotalDuration().getSeconds()
				);
				return dur;		
	}
	
	/**
	 * Return a formmatted string representation of the <code>Duration</code>
	 * in <code>d</code>.
	 *
	 * @param d		The <code>Duration</code> to be copied into a formatted
	 * 				string.
	 * @return		The formmatted string for <code>Duration d</code>.
	 */
	public static String getTotalDurationString(Duration d)
	{
		String dur = String.format
				(
					"%02d:%02d:%02d",
					d.getHours(),
					d.getMinutes(),
					d.getSeconds()
				);
				return dur;		
	}

	/**
	 * Start the <code>Tk_ActiveTimeRecord m_tr</code>, and grab the start and
	 * current time strings from it. Also setup the start time display, and then
	 * update the current time, duration and total duration displays.
	 */
	@Override
	public void startClock()
	{
		super.startClock();
		setStartTimeDisplay();
		setCurrentTimeDisplay();
		m_startTimeLabel.setText(m_startString);
		startDisplay();
	}
	
	/**
	 * Switch to a new task by creating and setting up the title border with
	 * the new task name, and initializing the <code>m_totalDuration</code>
	 * field.
	 * 
	 * @param new_task		The name of the task to switch to.
	 */
	@Override
	public void switchTasks(String new_task)
	{
		super.switchTasks(new_task);
		m_box.setBorder
		(
			BorderFactory.createTitledBorder
			(
				BorderFactory.createBevelBorder(BevelBorder.LOWERED),
				TaskPrefix + getCurrentTaskName()
			)
		);
	}

	/**
	 * Update the displays to their current values.
	 */
	@Override
	public void updateDisplay()
	{
		setCurrentTimeDisplay();
		setDurationDisplay();
		setTotalDurationDisplay();
		m_currentTimeLabel.setText(m_currentString);
		m_durationTimeLabel.setText(m_durationString);
		m_totalDurationTimeLabel.setText(m_totalDurationString);
	}
	
	/**
	 * Set the displayed values for current time, duration and total duration.
	 */
	public void startDisplay()
	{
		m_currentTimeLabel.setText(m_currentString);
		m_durationTimeLabel.setText(m_durationString);
		m_totalDurationTimeLabel.setText(m_totalDurationString);
	}
	
	/**
	 * Return the box that contains the <code>Tk_Digital</code>'s display.
	 * 
	 * @return		The Swing <code>Box</code> that contains the time display.
	 */
	public Box getBox()
	{
		return m_box;
	}

	public static void main(String[] args)
	{
		Tk_Digital td = new Tk_Digital("Programming");
		JFrame jf = new JFrame();
		jf.add(td.getBox());
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
		td.startClock();
	}

}
package Tk_Gui;

import java.util.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.geom.Path2D.Double;
import java.awt.font.*;
import javax.swing.*;
import javax.swing.plaf.ComponentUI;
import Tk_utils.*;
import javax.xml.datatype.*;

/**
 * <p>A somewhat generic graph. This graph class simply draws the axes, and if
 * <code>Tk_ChartEntry</code> elements are added to it, it will call their
 * paint methods as appropriate.</p>
 *
 * Fixme: We probably want to subclass this more general graph to the
 * specific type we use for the Time Keeper.
 * @author michaelwebster
 *
 */
public class Tk_Graph<T> extends JComponent implements Scrollable
{
	/**
	 * The graph direction can be left to right, right to left top to bottom
	 * or bottom to top. This field also implies a graph orientation. 
	 */
	private Tk_GraphDirection m_growDirection = Tk_GraphDirection.Illegal;
	

	/**
	 * The start of the range of values that can be shown on the y axis.
	 */
	private long m_startRange 			= 0;
	
	/**
	 * The largest of the range of values that can be shown on the y axis.
	 */
	private long m_endRange 			= 0;

	/**
	 * The height on screen as distinct from the height of the graph.
	 */
	private long m_heightOnScreen;
	
	/**
	 * The Conversion factor from range values to height on screen values.
	 */
	private double m_rangeXvFactor;

	/**
	 * The start of the domain of values that can be shown on the x axis.
	 */
	private long m_startDomain			= 0;
	
	/**
	 * The end of the domain of values that can be shown on the x axis.
	 */
	protected long m_endDomain			= 0;
	
	/**
	 * The width on the screen, as distinct from the width of the graph.
	 */
	protected long m_widthOnScreen;

	/**
	 * The Conversion factor from domain values to width on screen values.
	 */
	private double m_domainXvFactor;
	
	/**
	 * The value at which to place big ticks on the y axis.
	 */
	private long m_bigYTicks			= 0;
	
	/**
	 * The value at which to place small ticks on the y-axis
	 */
	private long m_smallYTicks			= 0;
	
	/**
	 * The value at which to place big ticks on the y axis.
	 */
	private long m_bigXTicks			= 0;
	
	/**
	 * The value at which to place small ticks on the y-axis
	 */
	private long m_smallXTicks			= 0;
	
	/**
	 * The label for the y axis.
	 */
	private String m_yLabel				= null;
	
	/**
	 * The label for the x axis.
	 */
	private String m_xLabel				= null;
	
	/**
	 * Width of the graph.
	 */
	private long m_graphWidth			= 0;
	
	/**
	 * Height of the graph.
	 */
	private long m_graphHeight			= 0;
	
	/**
	 * Buffer between the sides of the component and the axes of the graph.
	 */
	private long m_widthBuffer			= 0;
	
	/**
	 * Buffer between the top and bottom of the component and the axes of the
	 * graph.
	 */
	private long m_heightBuffer			= 0;

	/**
	 * The converter for converting between external values and our internal
	 * representation.
	 */
	private Tk_Converter<T, Long> m_converter 	= null;
	
	/**
	 * The current size of the graph.
	 */
	Font m_font = null;
	
	/**
	 * The x axis label's glyph vector.
	 */
	GlyphVector m_xGlyphVector = null;
	
	/**
	 * The y axis label's glyph vector.
	 */
	GlyphVector m_yGlyphVector = null;
	
	/**
	 * The path containing the X axis for the graph.
	 */
	private Path2D.Double m_xAxis = null;
	
	/**
	 * The path containing the Y axis for the graph.
	 */
	private Path2D.Double m_yAxis = null;
	
	/**
	 * The stroke for drawing the axes.
	 */
	private Stroke m_mainStroke			= null;
	
	/**
	 * The path containing the small ticks for the x-axis of the graph.
	 */
	protected Path2D.Double m_smallXTicksPath = null;
	
	/**
	 * The path containing the small ticks for the y axis of the graph.
	 */
	protected Path2D.Double m_smallYTicksPath = null;

	/**
	 * The stroke for drawing the small ticks.
	 */
	private Stroke m_smallTickStroke	= null;
	
	/**
	 * The stroke for drawing the big ticks.
	 */
	private Stroke m_bigTickStroke		= null;
	
	/**
	 * The path containing the big ticks for x-axis of the graph.
	 */
	private Path2D.Double m_bigXTicksPath = null;
	
	/**
	 * The path containing the big ticks for the y axis of the graph.
	 */
	private Path2D.Double m_bigYTicksPath = null;
	
	/**
	 * The length of the arrow lines on the axes.
	 */
	private int m_arrowLength			= 0;
	
	/**
	 * The vector containing the glyphs for labelling the values on the y-axis. 
	 */
	private Vector<GlyphVector>		m_yGlyphs			= null;
	
	/**
	 * The Font for labelling the values on the y-axis.
	 */
	private Font 					m_yLabelFont			= null;

	/**
	 * A vector of <code>Tk_ChartEntry</code>s that draw the graphed quantities
	 * on the graph.
	 */
	protected HashMap<String, Tk_ChartEntry>m_entries		= null;

	/**
	 * Create the Tk_Graph.
	 * @param gd				The direction of growth.
	 * @param height_on_screen	The height of the graph component.
	 * @param start_range		The beginning of the y-axis range of values.
	 * @param end_range			The end of the y-axis range of values.
	 * @param width_on_screen	The width of the graph component.
	 * @param start_domain		The beginning of the x-axis' domain of values.
	 * @param end_domain		The end of the x-axis' domain of values.
	 * @param big_y_ticks		The distance between big ticks on the y-axis. 
	 * @param small_y_ticks 	The distance between small ticks on the y-axis.
	 * @param big_x_ticks   	The distance between big ticks on the x-axis.
	 * @param small_x_ticks 	The distance between small ticks on the y-axis.
	 * @param x_label			The label for the x axis.
	 * @param y_label			The label for the y axis.
	 * @param converter			A value converter.
	 */
	public Tk_Graph
	(
		Tk_GraphDirection gd,
		long height_on_screen,
		long start_range,
		long end_range,
		long width_on_screen,
		long start_domain,
		long end_domain,
		long big_y_ticks,
		long small_y_ticks,
		long big_x_ticks,
		long small_x_ticks,
		String x_label,
		String y_label,
		Tk_Converter<T, Long> converter
	)
	{
		super();
		m_growDirection 	= gd;
		m_heightOnScreen 	= height_on_screen;
		m_startRange 		= start_range;
		m_endRange			= end_range;
		m_rangeXvFactor		= ((double)m_heightOnScreen)/(double)(m_endRange - m_startRange);
		m_widthOnScreen		= width_on_screen;
		m_startDomain		= start_domain;
		m_endDomain			= end_domain;
		assert((m_bigYTicks % m_smallYTicks) == 0);
		m_bigYTicks			= big_y_ticks;
		m_smallYTicks		= small_y_ticks;
		m_bigXTicks			= big_x_ticks;
		m_smallXTicks		= small_x_ticks;
		assert(m_smallXTicks == 0 || (m_bigYTicks % m_smallYTicks) == 0);
		m_graphWidth = m_widthOnScreen;
		m_widthBuffer = m_graphWidth / 4;
		if (0 == m_smallXTicks)
		{
			m_domainXvFactor = 1.0;
		}
		else
		{
			m_domainXvFactor	= ((double)m_widthOnScreen)/(double)(m_endDomain- m_startDomain);
		}
		m_graphHeight = m_heightOnScreen;
		m_heightBuffer = m_graphHeight / 10;
		m_xLabel			= x_label;
		m_yLabel			= y_label; 
		m_converter			= converter;
		int stroke_width =
				(int)Math.ceil
	    		(
	        		(double)(Math.min(m_heightOnScreen, m_widthOnScreen)) / 300
	       		);
		System.out.printf("Stroke width is %d\n", stroke_width);
		m_mainStroke = new BasicStroke(stroke_width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
		m_smallTickStroke = new BasicStroke(Math.max(stroke_width / 2, 1));
		m_bigTickStroke = new BasicStroke(stroke_width);
		m_arrowLength = Math.max((int)m_graphWidth, (int)m_graphHeight)/50;
		m_entries = new HashMap<String, Tk_ChartEntry>();
		
		this.setOpaque(true);
		m_xAxis = new Path2D.Double();
		m_yAxis = new Path2D.Double();
		createYAxis();
		//createXAxis();
	}

	/**
	 * Reset this component's dimensions based on a change to the width on
	 * screen attribute.
	 */
	protected void setDimensions()
	{
		m_graphWidth = m_widthOnScreen;
		setBounds(new Rectangle(0 ,0, (int)getComponentWidth(), (int)getComponentHeight()));	
	}

	/**
	 * <p>Create the x-axis by:
	 * <ol>
	 * <li>Draw the x-axis,</li>
	 * <li>Draw an arrow on the end of the x-axis,</li>
	 * <li>Draw the big and small ticks on the x-axis.</li>
	 * </ol>
	 * </p>  
	 */
	protected void createXAxis()
	{
		System.out.println("In Tk_Graph.createXAxis()");
		double angle = Math.PI / 4;
		double x_diff = Math.sin(angle) * m_arrowLength;
		double y_diff = Math.cos(angle) * m_arrowLength;
		m_xAxis.reset();
		// Return to the origin.
		m_xAxis.moveTo(getWidthBuffer(), 11 * getHeightBuffer());
		// Draw the X axis.;
		m_xAxis.lineTo(1.8 * getWidthBuffer() + getGraphWidth(), 11 * getHeightBuffer());
		System.out.printf("Writing x axis from x = %d to x = %f\n",
				getWidthBuffer(), 1.8 * getWidthBuffer() + getGraphWidth());
		
		// Place an arrow on the end of the x axis.
		m_xAxis.lineTo(1.8 * getWidthBuffer() + getGraphWidth() - x_diff, 11 * getHeightBuffer() + y_diff);
		m_xAxis.moveTo(1.8 * getWidthBuffer() + getGraphWidth(), 11 * getHeightBuffer());
		m_xAxis.lineTo(1.8 * getWidthBuffer() + getGraphWidth() - x_diff, 11 * getHeightBuffer() - y_diff);
		
		m_bigXTicksPath = new Path2D.Double();
		m_smallXTicksPath = new Path2D.Double();
		
		// Place small and large ticks on the x axis.
		if (m_bigXTicks > 0)
		{
			if (m_smallXTicks > 0)
			{
				long x_val = m_smallXTicks;
				while (x_val < m_endDomain - m_startDomain)
				{
					long x_convert = convertXVal(x_val);
					if ((x_val  % m_bigXTicks) == 0)
					{
						m_bigXTicksPath.moveTo(getWidthBuffer() + x_convert, 11 * getHeightBuffer());
						m_bigXTicksPath.lineTo(getWidthBuffer() + x_convert, 11.3 * getHeightBuffer());
					}
					else
					{
						m_smallXTicksPath.moveTo(getWidthBuffer() + x_convert, 11 * getHeightBuffer());
						m_smallXTicksPath.lineTo(getWidthBuffer() + x_convert, 11.1 * getHeightBuffer());
					}
					x_val += (m_smallXTicks > 0) ? m_smallXTicks : m_bigXTicks;
				}
			}
		}
	}

	/**
	 * <p>Create the y-axis by:
	 * <ol>
	 * <li>Draw the y-axis,</li>
	 * <li>Draw an arrow on the end of the y-axis,</li>
	 * <li>Draw the big and small ticks on the y-axis.</li>
	 * </ol>
	 * </p>  
	 */
	protected void createYAxis()
	{
		setDimensions();
		Rectangle r = getBounds();
		System.out.printf("Got Bounds = %s\n", r);
		
		// Move to the origin for the axes.
		m_yAxis.moveTo(getWidthBuffer(), 11 * getHeightBuffer());
		// Draw the Y axis.
		m_yAxis.lineTo(getWidthBuffer(), getHeightBuffer());
		
		// Place an arrow on the end of the y axis.
		double angle = Math.PI / 4;
		double x_diff = Math.sin(angle) * m_arrowLength;
		double y_diff = Math.cos(angle) * m_arrowLength;
		m_yAxis.lineTo(getWidthBuffer() - x_diff, getHeightBuffer() + y_diff);
		m_yAxis.moveTo(getWidthBuffer(), getHeightBuffer());
		m_yAxis.lineTo(getWidthBuffer() + x_diff, getHeightBuffer() + y_diff);
		
		
		m_bigYTicksPath = new Path2D.Double();
		m_smallYTicksPath = new Path2D.Double();
		// Place small and large ticks on the y axis.
		long y_val = m_smallYTicks;
		while (y_val < m_endRange - m_startRange)
		{
			long y_convert = convertYVal(y_val);
			if ((y_val  % m_bigYTicks) == 0)
			{
				//getComponentHeight()  - getHeightBuffer() - y_convert;	    		
//				m_bigYTicksPath.moveTo(getWidthBuffer(), getHeightBuffer() + y_convert);
//				m_bigYTicksPath.lineTo(0.7 * getWidthBuffer(), getHeightBuffer() + y_convert);
				m_bigYTicksPath.moveTo
				(
					getWidthBuffer(),
					getComponentHeight()  - getHeightBuffer() - y_convert
				);
				m_bigYTicksPath.lineTo
				(
					0.7 * getWidthBuffer(),
					getComponentHeight()  - getHeightBuffer() - y_convert
				);
			}
			else
			{
				//m_smallYTicksPath.moveTo(getWidthBuffer(), getHeightBuffer() + y_convert);
				//m_smallYTicksPath.lineTo(0.9 * getWidthBuffer(), getHeightBuffer() + y_convert);
				m_smallYTicksPath.moveTo
				(
					getWidthBuffer(),
					getComponentHeight()  - getHeightBuffer() - y_convert
				);
				m_smallYTicksPath.lineTo
				(
					0.9 * getWidthBuffer(),
					getComponentHeight()  - getHeightBuffer() - y_convert
				);
			}
			y_val += m_smallYTicks;
		}
	}

	/**
	 * Convert between a value in the graph's range, and a screen height
	 * value.
	 * @param yval		A value from the range <code>[m_endRange - m_startRange]</code>
	 * @return			A screen height value on the graph y-axis. 
	 */
	protected long convertYVal(long yval)
	{
		return (long)Math.ceil(m_rangeXvFactor * yval);
	}
	
	/**
	 * Convert between a value in the graph's domain and a screen width
	 * value.
	 * @param xval		A value from the domain <code>[m_endDomain - m_startDomain]</code>
	 * @return			A screen width value on the graph x-axis. 
	 */
	protected long convertXVal(long xval)
	{
		return (long)Math.ceil(m_domainXvFactor * xval);
	}

	/**
	 * Has this category been seen before.
	 * 
	 * @param cat_name	The name of a category.
	 *
	 * @return	true => the category has been seen before.
	 * 			false otherwise.
	 */
	protected boolean hasElement(String cat_name)
	{
		return m_entries.containsKey(cat_name);
	}
	
	/**
	 * Add a <code>Tk_ChartEntry</code> with category name cat_name.
	 * 
	 * @param cat_name		The category name fot his char entry.
	 * @param tke			The chart entry itself.
	 */
	protected void addElement(String cat_name, Tk_ChartEntry tke)
	{
		m_entries.put(cat_name, tke);
	}
	
	/**
	 * Return the <code>Tk_CharEntry</code> with category name = cat_name.
	 *
	 * @param cat_name	The name of the <code>Tk_ChartEntry</code> we awant to
	 * 					retrieve.
	 *
	 * @return	The requested <code>Tk_ChartEntry</code>.
	 */
	protected Tk_ChartEntry getElement(String cat_name)
	{
		return m_entries.get(cat_name);
	}

	/**
	 * Paint the graph, including any <code>Tk_ChartEntry</code>s that belong
	 * on the graph.
	 */
	@Override
	public void paintComponent(Graphics g)
    {
		//System.out.println("In paintComponent!");
    	super.paintComponent(g);
    	Graphics2D g2 = (Graphics2D)g;

    	// If the font is null, create it and the glyph vectors for labelling
    	// the x and y axes.
    	if (null == m_font)
    	{
    		m_font = new Font("Serif", Font.BOLD, (int)(m_heightBuffer/2));
    		g2.setFont(m_font);
    		m_xGlyphVector = m_font.createGlyphVector(g2.getFontRenderContext(), m_xLabel);
    		m_yGlyphVector = m_font.createGlyphVector(g2.getFontRenderContext(), m_yLabel);
    	}
    	g2.setStroke(m_mainStroke);
    	g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
    			RenderingHints.VALUE_ANTIALIAS_ON);
    	g2.draw(m_yAxis);
    	g2.draw(m_xAxis);
    	// Add the x-axis label.
    	g2.drawGlyphVector
    	(
    		m_xGlyphVector,
    		(float)getComponentWidth()/3,
    		(float)(getComponentHeight())// - getHeightBuffer() / 8)
    	);
    	
    	// Add the y-axis label.
    	g2.drawGlyphVector
    	(
    		m_yGlyphVector,
    		(float)getWidthBuffer()/2,
    		(float)(getHeightBuffer() / 2)
    	);
    	
    	// Render the big ticks.
    	g2.setStroke(m_bigTickStroke);
    	g2.draw(m_bigYTicksPath);
    	g2.draw(m_bigXTicksPath);
    	
    	// Render the small ticks.
    	g2.setStroke(m_smallTickStroke);
    	g2.draw(m_smallYTicksPath);
    	g2.draw(m_smallXTicksPath);
    	
    	Iterator<String> it = m_entries.keySet().iterator();
    	while (it.hasNext())
    	{
    		Tk_ChartEntry tce = m_entries.get(it.next());
    		//tce.paint();
    		tce.paint(g2);
    	}
    	
    	// If the font is null, create it and the glyph vectors for labelling
    	// the x and y axes.
    	if (null == m_yLabelFont)
    	{
    		m_yLabelFont = new Font("Serif", Font.BOLD, (int)Math.min(getHeightBuffer()/2, getWidthBuffer()/2));
    		m_yGlyphs = new Vector<GlyphVector>();
    		g2.setFont(m_yLabelFont);
    		// Place small and large ticks on the y axis.
    		long y_val = m_bigYTicks;
    		AffineTransform at = null;
    		String longest_string = null;
    		Rectangle2D longest_rect = null;
    		while (y_val < m_endRange - m_startRange)
    		{
    			String next_label = m_converter.getStringSecond(y_val);
    			Rectangle2D string_rec = 
    					m_yLabelFont.getStringBounds(next_label, g2.getFontRenderContext());
    			if (longest_rect == null)
    			{
    				longest_rect = string_rec;
    				longest_string = next_label;
    			}
    			else if (longest_rect.getWidth() < string_rec.getWidth())
    			{
    				longest_rect = string_rec;
    				longest_string = next_label;
    			}
    			y_val += m_bigYTicks;
    		}
    		double y_scale = 0.5 * getWidthBuffer() / longest_rect.getWidth();
    		at = AffineTransform.getScaleInstance(y_scale, y_scale);
    		Font scaled_font = m_yLabelFont.deriveFont(at);
    		
    		y_val = m_bigYTicks;
    		while (y_val < m_endRange - m_startRange)
    		{
    			long y_convert = convertYVal(y_val);
    			String next_label = m_converter.getStringSecond(y_val);
    			m_yGlyphs.add
    			(
   					scaled_font.createGlyphVector(g2.getFontRenderContext(), next_label)
    			);
    			y_val += m_bigYTicks;
    		}
    	}

    	for (int i = 0; i < m_yGlyphs.size(); i++)
    	{
    		long y_convert = convertYVal(m_bigYTicks * (i + 1));
    		long next_y_pos = getComponentHeight()  - getHeightBuffer() - y_convert;
    		GlyphVector gv = m_yGlyphs.get(i);
    		Shape s = gv.getOutline();
    		g2.drawGlyphVector
    		(
    			gv,
    			(float)(getWidthBuffer())/8, // - 1.2 * s.getBounds().width),
    			(float)next_y_pos + s.getBounds().height/2
    		);
    	}
    }
	
	/**
	 * Add the supplied <code>Tk_ChartEntry</code> to this graph.
	 * 
	 * @param tkc 		A new entry for rendering on this graph.
	 */
	public void addGraphElement(String name, Tk_ChartEntry tkc)
	{
		m_entries.put(name, tkc);
	}
	
	@Override
	public void setSize(Dimension d)
	{
		super.setSize(d);
	}

	@Override
	public Dimension getPreferredSize()
	{
		return new Dimension((int)getComponentWidth(), (int)getComponentHeight());
	}

	@Override
	public Dimension getMinimumSize()
	{
		return new Dimension((int)getComponentWidth(), (int)getComponentHeight());
	}
	
	@Override
	public Dimension getMaximumSize()
	{
		return new Dimension((int)getComponentWidth(), (int)getComponentHeight());
	}
	
	/**
	 * Return the <code>Tk_GraphDirection</code> direction of growth of this
	 * <code>Tk_Graph</code>.
	 *
	 * @return	A <code>Tk_GraphDirection</code> enumeration value indicating
	 * 			the direction in which this graph grows.
	 */
	public Tk_GraphDirection getGrowDirection()
	{
		return m_growDirection;
	}

	/**
	 * Return the start value for the y-axis of this graph.
	 *
	 * @return	The start value on the y-axis of this graph.
	 */
	public long getStartRange()
	{
		return m_startRange;
	}
	
	/**
	 * Return the last value displayed on the y-axis of this graph.
	 *
	 * @return	The last value displayed on the y-axis of the graph.
	 */
	public long getEndRange()
	{
		return m_endRange;
	}
	
	/**
	 * Return the height on screen that has been requested for this graph.
	 *
	 * @return		The height on screen that has been requested for this
	 * 				graph.
	 */
	public long getHeightOnScreen()
	{
		return m_heightOnScreen;
	}

	/**
	 * Return the conversion factor used to convert from value ranges to
	 * screen height values.
	 *
	 * @return		The conversion factor mulitplier for range values, to
	 * 				get screen values.
	 */
	public double getRangeConversionFactor()
	{
		return this.m_rangeXvFactor;
	}
	
	/**
	 * Return the start value for the x-axis of this graph.
	 *
	 * @return	The start value on the x-axis of this graph.
	 */
	public long getStartDomain()
	{
		return m_startDomain;
	}
	
	/**
	 * Return the last value displayed on the x-axis of this graph.
	 *
	 * @return	The last value displayed on the x-axis of the graph.
	 */
	public long getEndDomain()
	{
		return m_endDomain;
	}
	
	/**
	 * Return the conversion factor used to convert from domain values to
	 * screen width values.
	 *
	 * @return		The conversion factor mulitplier for domain values, to
	 * 				get screen values.
	 */
	public double getDomainConversionFactor()
	{
		return this.m_domainXvFactor;
	}

	/**
	 * Return the value at which to place big ticks on the y axis.
	 * 
	 * @return The distance between big ticks on the y-axis of the graph.
	 */
	public long getBigYTicks()
	{
		return m_bigYTicks;
	}
	
	/**
	 * Return the value at which to place small ticks on the y-axis
	 *
	 * @return The distance between small ticks on the y-axis of the graph.
	 */
	public long getSmallYTicks()
	{
		return m_smallYTicks;
	}
	
	/**
	 * Return the value at which to place big ticks on the x axis.
	 *
	 * @return The distance between big ticks on the x-axis of the graph.
	 */
	public long getBigXTicks()
	{
		return m_bigXTicks;
	}
	
	/**
	 * Return the value at which to place small ticks on the x-axis
	 *
	 * @return The distance between small ticks on the x-axis of the graph.
	 */
	private long getSmallXTicks()
	{
		return m_smallXTicks;
	}
	
	/**
	 * Return  the label for the y axis.
	 *
	 * @return The label for the y axis of this graph.
	 */
	public String getYLabel()
	{
		return m_yLabel;
	}
	
	/**
	 * Return the label for the x axis.
	 *
	 * @return The label for the x-axis of this graph.
	 */
	public String getXLabel()
	{
		return m_xLabel;
	}
	
	/**
	 * Return the height of this graph.
	 *
	 * @return	The height of this graph.
	 */
	public long getGraphHeight()
	{
		return m_graphHeight;
	}
	
	/**
	 * Return the width of this graph.
	 *
	 * @return	The width of this graph.
	 */
	public long getGraphWidth()
	{
		return m_graphWidth;
	}
	
	/**
	 * Return the buffer between the edge of the component and the y-axis of
	 * the graph.
	 *
	 * @return	The distance between the edge of the component and the y-axis
	 * 			of this graph.
	 */
	public long getWidthBuffer()
	{
		return m_widthBuffer;
	}
	
	/**
	 * Return the buffer between the edge of the component and the x-axis of
	 * the graph.
	 *
	 * @return	The distance between the edge of the component and the x-axis
	 * 			of this graph.
	 */
	public long getHeightBuffer()
	{
		return m_heightBuffer;
	}
	
	/**
	 * Return the height of the component, including the graph height, and the
	 * two height buffers.
	 *
	 * @return	The height of the entire component.
	 */
	public long getComponentHeight()
	{
		return m_graphHeight + 2 * m_heightBuffer;
	}
	
	/**
	 * Return the width of the component, including the graph width, and the
	 * two width buffers.
	 *
	 * @return	The width of the entire component.
	 */
	public long getComponentWidth()
	{
		return m_graphWidth + 2 * m_widthBuffer;
	}

	/**
	 * Just a main method to be called from the event thread.
	 */
	public static void drawGraph()
	{
		JFrame jf = new JFrame();
		Tk_Graph<Duration> tkb =
			new Tk_Graph<Duration>
			(
				Tk_GraphDirection.LeftToRight,
				600,
				0,
				1000,
				900,
				0,
				800,
				50,
				10,
				50,
				10,
				"X Label",
				"Y Label",
				(Tk_Converter)(new Tk_LongLong())
			);
		tkb.createYAxis();
		tkb.createXAxis();
		jf.setUndecorated(false);
		jf.add(tkb);
		Tk_MouseListener tml = new Tk_MouseListener(jf);
		jf.addMouseListener(tml);		
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}
	
	public static void main(String[] args)
	{
		SwingUtilities.invokeLater
		(
			new Runnable()
			{
				public void run()
				{
					drawGraph();
				}
			}
		);
	}

	@Override
	public Dimension getPreferredScrollableViewportSize()
	{
		Dimension d = new Dimension((int)getComponentWidth(), (int)(1.05 * getComponentHeight()));
		System.out.printf("Tk_Graph:getPreferredScrollableViewPortSize()\n");
		System.out.printf("Dimension is: %s\n", d.toString());
		return d;
	}

	@Override
	public int getScrollableUnitIncrement
	(
		Rectangle visibleRect,
		int orientation,
		int direction
	)
	{
		return 0;
	}

	@Override
	public int getScrollableBlockIncrement(Rectangle visibleRect,
			int orientation, int direction) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean getScrollableTracksViewportWidth()
	{
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean getScrollableTracksViewportHeight()
	{
		// TODO Auto-generated method stub
		return false;
	}

}

class EmptyUI extends ComponentUI
{
	private static final EmptyUI sharedInstance = new EmptyUI();
	public static ComponentUI createUI(JComponent c)
	{
		return sharedInstance;
	}
}
package Tk_Gui;

public enum Tk_GraphDirection 
{
	LeftToRight,
	RightToLeft,
	Upwards,
	Downwards,
	Illegal;
}
package Tk_Gui;

import java.util.*;
import java.awt.*;
import javax.swing.*;
import javax.swing.border.BevelBorder;

public class Tk_GraphLegend extends JPanel
{
	/*public static String[]strings =
	{
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday",
		"Sunday"
	};
	
	public static Color[]colours = 
		{
		Color.blue,
		Color.magenta,
		Color.green,
		Color.red,
		Color.yellow,
		Color.cyan,
		Color.orange,
        Color.pink,
        Color.gray,
        Color.darkGray,
        Color.black,
        Color.lightGray
    };*/

	private Vector<JPanel>m_legendEntries = null;
	private HashMap<String, Color>m_entryMap = null;
	
	public Tk_GraphLegend(Rectangle r)
	{
		super();
		setMinimumSize(r.getSize());
		setPreferredSize(r.getSize());
		setMaximumSize(r.getSize());
		setBounds(r);
		//setBorder(BorderFactory.createTitledBorder("Graph Legend"));

		m_entryMap = Tk_BarChartEntry.getColourMap();
		setLayout(new FlowLayout());
		createLegendEntries();
		JLabel glegend = new JLabel("Graph Legend:");
		add(glegend);
		Iterator<JPanel>pit = m_legendEntries.iterator();
		//Rectangle r = new Rectangle();
		
		while (pit.hasNext())
		{
			JPanel jp = pit.next();
			System.out.println("Adding a JPanel");
			add(jp);
		}
		System.out.printf("r is %s\n", r.toString());
	}
	
	/*public void paintComponent(Graphics g)
	{
		super.paintComponent(g);
	}*/

	private void createLegendEntries()
	{
		Iterator<String>sit = m_entryMap.keySet().iterator();
		m_legendEntries = new Vector<JPanel>();
		while (sit.hasNext())
		{
			String n = sit.next();
			System.out.printf("Creating entry for %s\n", n);
			JLabel colorLabel 	= new JLabel();
			colorLabel.setOpaque(true);
			Rectangle r = new Rectangle(0,0,20,20);
			colorLabel.setMinimumSize(r.getSize());
			colorLabel.setMaximumSize(r.getSize());
			colorLabel.setPreferredSize(r.getSize());
			colorLabel.setBounds(r);
			colorLabel.setBackground(m_entryMap.get(n));
			JLabel nameLabel	= new JLabel(n);
			JPanel jp = new JPanel();
			jp.add(colorLabel);
			jp.add(nameLabel);
			jp.setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));
			//add(jp);
			System.out.printf("Painting colour = %h\n", m_entryMap.get(n));
			m_legendEntries.add(jp);
		}
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		JFrame jf = new JFrame("Testing");
		
		Rectangle r = new Rectangle(50,50, 200,200);
		Tk_GraphLegend tgl = new Tk_GraphLegend(r);
		//jf.setUndecorated(true);
		jf.add(tgl);
		jf.pack();
		//tgl.setBounds(new Rectangle(0,0,200,200)); //tgl.getBounds());
		jf.setVisible(true);
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

	}

}
package Tk_Gui;

import java.util.*;
import javax.swing.*;
import java.awt.*;
//import java.awt.Rectangle;
import javax.swing.Scrollable;
import javax.xml.datatype.*;
import Tk_utils.*;

public class Tk_HistoryGraph extends Tk_BarGraph<Duration>
{
	/*
	 * public Tk_BarGraph
	(
		Tk_GraphDirection gd,
		long height_on_screen,
		long start_range,
		long end_range,
		long width_on_screen,
		Vector<String>x_categories,
		long big_y_ticks,
		long small_y_ticks,
		String x_label,
		String y_label,
		Tk_Converter<T, Long> converter,
		long graph_entry_width
	)
	 */
	public Tk_HistoryGraph
	(
		Tk_GraphDirection gd,
		long height_on_screen,
		long start_range,
		long end_range,
		long width_on_screen,
		Vector<String>x_categories,
		long big_y_ticks,
		long small_y_ticks,
		String x_label,
		String y_label,
		long graph_entry_width
	)
	{
		super
		(
			gd,
			height_on_screen,
			start_range,
			end_range,
			width_on_screen,
			x_categories,
			big_y_ticks,
			small_y_ticks,
			x_label,
			y_label,
			new Tk_DurationConverter(),
			graph_entry_width				
		);
	}
	
	@Override
	public void paintComponent(Graphics g)
	{
		super.paintComponent(g);
	}


	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		String test_data[] =
			{
				"Monday",
				"Tuesday",
				"Wednesday",
				"Thursday",
				"Friday",
				"Saturday",
				"Sunday"
			};
		Vector<String>vs = new Vector<String>();
		for (int i = 0; i < test_data.length; i++)
		{
			vs.add(test_data[i]);
		}
		JFrame jf = new JFrame();

		Tk_HistoryGraph tkb =
			new Tk_HistoryGraph
			(
				Tk_GraphDirection.LeftToRight,
				200,
				0,
				60 * 60 *12,
				400,
				vs,
				60 * 60,
				15 * 60,
				"Task Record Date",
				"Task Time",
				100
			);

		//tkb.createGraph();
		for (int i = 0; i < vs.size(); i++)
		{
			int bar_num = 1 + (int)Math.ceil(10 * Math.random());
			for (int j = 0; j < bar_num; j++)
			{
				long h = (long)Math.ceil(60 * 60 * 12 * Math.random());
				String bar_name = String.format("%s:%s:%d", vs.get(i), "bar", j);
				tkb.addBarElement(vs.get(i), bar_name, tkb.getWidthBuffer() + i * tkb.getEntryWidth(), h);
			}
		}
		JScrollPane jsc = new JScrollPane(tkb);
		jsc.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);
		jsc.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		jsc.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
		jf.setUndecorated(false);
		jf.add(jsc);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}

}
package Tk_Gui;

import java.util.*;
import java.io.*;
import javax.xml.datatype.*;
import java.awt.*;
import javax.swing.*;
import Tk_History.*;
import Tk_Configuration.*;
import Tk_utils.*;

public class Tk_HistoryPanel// extends JPanel
{
	private Tk_TaskCollection 	m_taskCollection 	= null;
	private Tk_TaskHistory 	  	m_taskHistory 		= null;
	private Tk_HistoryGraph		m_historyGraph		= null;
	Vector<String>m_currentTaskNames				= null;
	
	TreeMap<GregorianCalendar, TreeMap<String, Duration>>
		m_durationMap = null;
	Vector<String>m_dates		= null;
	long m_longestSeconds		= 0;
	
	private JScrollPane			m_sPane				= null;
	private JPanel 				m_graphPanel 		= null;
	private Tk_GraphLegend		m_graphLegend		= null;		
	
	public Tk_HistoryPanel
	(
		String task_xml_file,
		String task_xsd_file,
		String history_xml_file,
		String history_xsd_file
	)
	{
		super();
		m_taskCollection = new Tk_TaskCollection(task_xml_file, task_xsd_file);
		m_taskHistory = new Tk_TaskHistory(history_xml_file, history_xsd_file);
		m_currentTaskNames = new Vector<String>();
		
		DefaultComboBoxModel<String>tasks = m_taskCollection.getCurrentList();
		
		for (int i = 0; i < tasks.getSize(); i++)
		{
			m_currentTaskNames.add(i, tasks.getElementAt(i));
		}
		
		getDurationMap();
		m_sPane = 
				new JScrollPane
				(
					ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER,
					ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS
				);
		m_sPane.setBorder(null);
		m_sPane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);
		createGraph();
		m_graphPanel = new JPanel();
		m_graphPanel.setLayout(new BoxLayout(m_graphPanel, BoxLayout.Y_AXIS));
		Rectangle r = m_historyGraph.getBounds();
		System.out.printf("m_sPane's bounds are %s\n", r.toString());
		m_graphLegend = new Tk_GraphLegend(new Rectangle(0,0,r.width,80));
		m_graphLegend.setBackground(Color.white);
		m_graphPanel.add(m_graphLegend);
		m_graphPanel.add(m_sPane);
	}
	
	public void setupHistoryGraph()
	{
		m_dates = new Vector<String>();
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord(long, long, long) constructor."
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}
		Duration longest_duration = dtf.newDuration((long)0);

		Iterator<GregorianCalendar>gcit = m_durationMap.keySet().iterator();
		while (gcit.hasNext())
		{
			GregorianCalendar gc = gcit.next();
			Date d = gc.getTime();
			String[] date_fields = d.toString().split("\\s");
			
			m_dates.add
			(String.format
				(
					"%s %s %s %s",
					date_fields[0],
					date_fields[1],
					date_fields[2],
					date_fields[date_fields.length - 1]
				)
			);
			TreeMap<String, Duration>tmap = m_durationMap.get(gc);
			Iterator<Duration>dit = tmap.values().iterator();
			while (dit.hasNext())
			{
				Duration next_duration = dit.next();
				int comparison = longest_duration.compare(next_duration); 
				if (comparison == DatatypeConstants.LESSER)
				{
					longest_duration = next_duration;
				}
			}
			
		}
		
		m_longestSeconds = longest_duration.getHours() * 3600
				+
				longest_duration.getMinutes() * 60
				+
				longest_duration.getSeconds();
		
		m_historyGraph = 
			new Tk_HistoryGraph
			(
				Tk_GraphDirection.LeftToRight,
				300,
				0,
				60 * 60 * 12,
				//m_longestSeconds,
				300,
				m_dates,
				3600, //3600,
				15 * 60, // * 60,
				"Task Record Date",
				"Task Time",
				150
			);
		addBars();
	}
	
	public void createGraph()
	{
		setupHistoryGraph();
		m_sPane.setViewportView(m_historyGraph);
	}

	public void addBars()
	{
		Iterator<GregorianCalendar>gcit = m_durationMap.keySet().iterator();
		int i = 0;
		while (gcit.hasNext())
		{
			GregorianCalendar category = gcit.next();
			TreeMap<String, Duration>tmap = m_durationMap.get(category);
			Iterator<String>sit = tmap.keySet().iterator();
			while (sit.hasNext())
			{
				String bar_name = sit.next();
				Duration d = tmap.get(bar_name);
				long seconds = d.getHours() * 3600 + d.getMinutes() * 60; // + d.getSeconds();
				//long minutes = d.getHours() * 60 + d.getMinutes(); // + d.getSeconds();
				m_historyGraph.addBarElement
				(
						String.format
						(
							"%02d:%02d:%02d",
							category.get(Calendar.YEAR),
							category.get(Calendar.MONTH + 1),
							category.get(Calendar.DAY_OF_MONTH)
						),
					bar_name, 
					m_historyGraph.getWidthBuffer() + i * m_historyGraph.getEntryWidth(),
					seconds
				);
			}
		i++;
		}
	}

	/**
	 * setup the m_durationMap TreeMap with a mapping from GregorianCalendars
	 * to a TaskName to duration map.
	 * 
	 * FIXME: We need to check that the end time of a task record is on the
	 * same day as the start time. If not, we should create one duration for
	 * the start day that ends at 12:00 AM, and another for the next day
	 * starting at 12:00AM.
	 */
	private void getDurationMap()
	{
		m_durationMap = 
				new TreeMap<GregorianCalendar, TreeMap<String, Duration>>();
		
		Iterator<String>sit = m_currentTaskNames.iterator();
		while (sit.hasNext())
		{
			String task_name = sit.next();
			TreeMap<GregorianCalendar, Vector<Tk_TimeRecord>> tm =
					m_taskHistory.getTaskMap(task_name);
			if (tm == null)
			{
				continue;
			}
			Iterator<GregorianCalendar>git = tm.keySet().iterator();
			while (git.hasNext())
			{
				GregorianCalendar gc = git.next();
				TreeMap<String, Duration>curr_record = null;
				Duration total_duration = null;
				
				Iterator<Tk_TimeRecord>trit = tm.get(gc).iterator();
				Tk_TimeRecord next_record = null;
				if (trit.hasNext())
				{
					 next_record = trit.next();
					 total_duration = next_record.getCurrentDuration();
					 if (!m_durationMap.containsKey(gc))
					 {
						 curr_record = new TreeMap<String, Duration>();
						 m_durationMap.put(gc, curr_record);
					 }
					 else
					 {
						 curr_record = m_durationMap.get(gc);
					 }
				}
				while (trit.hasNext())
				{
					next_record = trit.next();
					total_duration = total_duration.add(next_record.getCurrentDuration());
				}
				curr_record.put(task_name, total_duration);
			}
		}
	}

	public String getDurationMapString()
	{
		assert(m_durationMap != null);
		Iterator<GregorianCalendar>git = m_durationMap.keySet().iterator();
		String rval = "";
		while (git.hasNext())
		{
			GregorianCalendar gc = git.next();
			TreeMap<String, Duration>t_durations = m_durationMap.get(gc);
			rval += "\n==========================================\n";
			rval += String.format("Duration Records for day %s of month %s %s are:\n",
					gc.get(Calendar.DAY_OF_MONTH),
					gc.get(Calendar.MONTH),
					gc.get(Calendar.YEAR)
			);
			
			Iterator<String>task_it = t_durations.keySet().iterator();
			while (task_it.hasNext())
			{
				String tname = task_it.next();
				rval += String.format("Task Name %s has duration Records:\n", tname);
				Duration d = t_durations.get(tname);
				d = Tk_TimeRecord.normalizeDuration(d);
				String dur = String.format
						(
							"%02d:%02d:%02d",
							d.getHours(),
							d.getMinutes(),
							d.getSeconds()
						);
				rval += String.format("Total Duration(%s)\n", dur);
			}
		}
		return rval;
	}

	public JPanel getGraphPanel()
	{
		return m_graphPanel;
	}

	public static void runPanel()
	{
		String home = System.getProperty("user.home");
		String tk_dir = home.concat(Tk_FileUtil.Tk_XmlDir);
		String task_xml_file = tk_dir.concat(File.separator + "TK_TaskList.xml");
		String task_xsd_file = tk_dir.concat(File.separator + "TK_TaskList.xsd");
		String history_xml_file = tk_dir.concat(File.separator + "TK_History.xml");
		String history_xsd_file = tk_dir.concat(File.separator + "TK_History.xsd");
		System.out.printf("xml file is:\n%s\n", task_xml_file);
		System.out.printf("xsd file is:\n%s\n", task_xsd_file);
		System.out.printf("xml file is:\n%s\n", history_xml_file);
		System.out.printf("xsd file is:\n%s\n", history_xsd_file);
		Tk_HistoryPanel thp = new Tk_HistoryPanel
				(
					task_xml_file,
					task_xsd_file,
					history_xml_file,
					history_xsd_file
				);
		System.out.printf("The width of the graph is: %d \n", thp.m_historyGraph.getWidth());
		JFrame jf = new JFrame();
		jf.setUndecorated(false);
		jf.add(thp.m_graphPanel);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{

		SwingUtilities.invokeLater
		(
			new Runnable()
			{
				public void run()
				{
					runPanel();
				}
			}
		);
	}

}
package Tk_Gui;

import java.awt.FlowLayout;
import java.awt.event.*;
import java.util.*;
import org.w3c.dom.*;
import javax.swing.*;
import Tk_TaskSelectPanel.*;
import Tk_History.Tk_TaskHistory;
import Tk_utils.Tk_XmlUtil;
import Tk_utils.Tk_FileUtil;

/**
 * The main window for the TimeKeeper. This window contains and manages
 * the Tk_StartDisplay and Tk_TaskSelect panels, and handles the closing
 * of the application via the window close control, and the End button.
 *
 * @author michaelwebster
 *
 */
public class Tk_MainWindow extends JFrame implements ActionListener
{

	/**
	 * Location of the <code>TK_TaskList.xml</code> file template within the
	 * resources of this program.
	 */
	private static final String TaskXmlTemplate =
			"/Tk_Configuration/TestData/TK_TaskList.xml";
	
	/**
	 * Location of the <code>TK_TaskList.xsd</code> file template within the
	 * resources of this program.
	 */
	private static final String TaskXsdTemplate =
			"/Tk_Configuration/TestData/TK_TaskList.xsd";

	/**
	 * Location of the <code>TK_History.xml</code> file template within the
	 * resources of the program.
	 */
	public static final String HistoryXmlTemplate =
			"/Tk_Configuration/TestData/TK_History.xml";

	/**
	 * Location of the TK_History.xsd file template within this programs
	 * resources.
	 */
	public static final String HistoryXsdTemplate =
			"/Tk_Configuration/TestData/TK_History.xsd";

	/**
	 * Location of the <code>TK_TaskList.xml</code> file.
	 */
	private String m_taskXmlFile = null;

	/**
	 * Location of the <code>TK_TaskList.xsd</code> file.
	 */
	private String m_taskXsdFile = "null";

	/**
	 * Location of the <code>TK_History.xml</code> file.
	 */
	private String m_historyXmlFile = null;
	
	/**
	 * Location of the TK_History.xsd file.
	 */
	private String m_historyXsdFile = null;

	/**
	 * Dummy task name for when the TaskList is empty.
	 */
	public static final String NoTask			= "NoTask";
	
	/**
	 * Action command for the button that ends the time keeper session.
	 */
	private static final String EndTimeKeeper 	= "End";
	
	/**
	 * Action command for the button that displays the task history.
	 */
	private static final String ShowHistory 	= "Show";
	
	/**
	 * Action command for the button that switches to the bar graph view.
	 */
	private static final String GraphView = "Bar";

	/**
	 * The part of the GUI that handles task selection and editing.
	 */
	private Tk_TaskSelect		m_select		= null;
	
	/**
	 * The display that contains the time and duration for tasks, along with
	 * the Task switching buttons.
	 */
	private Tk_StartDisplay		m_start			= null;
	
	/**
	 * The button that ends the time keeping session.
	 */
	private JButton				m_endSession 	= null;
	
	/**
	 * The button that displays the task history.
	 */
	private JButton				m_showHistory	= null;
	
	/**
	 * The button that switches to the bar graph view.
	 */
	private JButton				m_showBarGraph;
	
	/**
	 * The task that is currently selected for timing.
	 */
	private String				m_currentTask	= null;
	
	/**
	 * Box to layout the <code>m_select</code> task select panel, the
	 * <code>m_start</code> display panel, and the <code>m_endSession</code>
	 * and <code>m_showHistory</code> JButtons.
	 */
	private Box					m_box			= null;
	
	/**
	 * <code>m_taskHistory</code> is used to record the task timing session
	 * to the TK_History.xml file when this task is terminated.
	 */
	private Tk_TaskHistory		m_taskHistory 	= null;
	
	/**
	 * A map containing a task name to xml time record  element lists
	 */
	private HashMap<String, Vector<Document>>m_timeRecordMap = null;

	/**
	 * Create the Main window by:
	 * - Instantiate the Tk_TaskSelect panel and add an action listener for
	 *   task selections in the combo box.
	 * - Instantiate the Tk_StartDisplay panel and 
	 * - Instantiate the m_endSession JButton.
	 * - Instantiate the m_showHistory JButton.
	 * - Setup a WindowAdapter to catch and handle the window closing event.
	 */
	public Tk_MainWindow()
	{
		super("TimeKeeper v0.1");
		Map<String, String>fmap =
			Tk_FileUtil.getXmlFiles
			(
				TaskXmlTemplate,
				TaskXsdTemplate,
				HistoryXmlTemplate,
				HistoryXsdTemplate
			);
		
		m_taskXmlFile 		= fmap.get(TaskXmlTemplate);
		m_taskXsdFile 		= fmap.get(TaskXsdTemplate);
		m_historyXmlFile 	= fmap.get(HistoryXmlTemplate);
		m_historyXsdFile 	= fmap.get(HistoryXsdTemplate);


		m_select = new Tk_TaskSelect(m_taskXmlFile, m_taskXsdFile);
		m_taskHistory = new Tk_TaskHistory(m_historyXmlFile, m_historyXsdFile);
		m_select.getComboBox().addActionListener(this);
		m_currentTask = m_select.getSelected();
	
		if (null == m_currentTask)
		{
			m_currentTask = NoTask;
		}
		
		m_start = new Tk_StartDisplay(m_currentTask);
		m_endSession = new JButton("End Time Keeper Session...");
		m_endSession.setActionCommand(EndTimeKeeper);
		m_endSession.addActionListener(this);
		m_showHistory = new JButton("Display History");
		m_showHistory.setMinimumSize(m_endSession.getMinimumSize());
		m_showHistory.setPreferredSize(m_endSession.getPreferredSize());
		m_showHistory.setMaximumSize(m_endSession.getMaximumSize());
		m_showHistory.setActionCommand(ShowHistory);
		m_showHistory.addActionListener(this);
		
		JPanel jp = new JPanel();
		jp.setLayout(new FlowLayout(FlowLayout.CENTER));
		jp.add(m_endSession);
		jp.add(m_showHistory);
		m_box = new Box(BoxLayout.PAGE_AXIS);
		m_box.add(m_select);
		m_box.add(m_start);
		m_box.add(jp);
		
		//m_box.add(m_showBarGraph);
		add(m_box);
		pack();
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		this.addWindowListener(new CloseAdapter());
		setVisible(true);
	}

	/**
	 * Handle:
	 * - the action indicating that a new task has been selected in m_select's
	 * Task Combo box.
	 * - Handle the EndTimeKeeper message from the m_endSession JButton.
	 */
	@Override
	public void actionPerformed(ActionEvent e)
	{
		if
		(
			e.getSource().equals(m_select.getComboBox())
			&&
			e.getActionCommand().equals(Tk_TaskSelect.SelectString)
		)
		{
			m_start.setSelectedTask(m_select.getSelected());
		}
		else if (e.getActionCommand().equals(EndTimeKeeper))
		{
			updateHistory();
			m_taskHistory.updateDom();
			this.dispose();
			System.exit(0);
		}
		else if (e.getActionCommand().equals(ShowHistory))
		{
			showHistory();
		}
		else if (e.getActionCommand().equals(GraphView))
		{
			System.out.println("Got action command:" + GraphView);
			//setupBarGraph();
			this.setVisible(false);
		}		
	}
	
	/**
	 * A Window Adapter to catch the windowClosing event, and, if the user
	 * confirms the close operation, get any remaining task time records
	 * from the m_start panel, and write them to the Tk_History.xml file.
	 * 
	 * @author michaelwebster
	 *
	 */
	class CloseAdapter extends WindowAdapter
	{
		/**
		 * Catch the window closing event, display a confirmation dialog, and
		 * if window closing is confirmed, grab any remaining time records from
		 * m_start, and write them back to the Tk_History file.
		 */
		public void windowClosing(WindowEvent e)
		{
			int confirm = JOptionPane.showOptionDialog
			(
				Tk_MainWindow.this,
				"Really Exit?",
				"Exit Confirmation",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE,
				null,
				null,
				null
			);
            
			if (confirm == 0)
			{
				updateHistory();
				m_taskHistory.updateDom();
				System.exit(0);
			}
		}
	}

	private void showHistory()
	{
		Tk_HistoryPanel hp =
			new Tk_HistoryPanel
			(
				m_taskXmlFile,
				m_taskXsdFile,
				m_historyXmlFile,
				m_historyXsdFile
			);
		JFrame jf = new JFrame();
		jf.setUndecorated(false);
		jf.add(hp.getGraphPanel());
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		jf.setVisible(true);
	}

	/**
	 * Get the time records from the m_start panel, and add them to the
	 * <code>Tk_TaskHistory</code> object for writing out to the history xml
	 * file.
	 */
	private void updateHistory()
	{
		m_timeRecordMap = m_start.getTimeRecords();
		Iterator<String>it = m_timeRecordMap.keySet().iterator();
		while (it.hasNext())
		{
			String tname = it.next();
			Vector<Document>docs = m_timeRecordMap.get(tname);
			for (int i = 0; i < docs.size(); i++)
			{
				Document cd = docs.elementAt(i);
				m_taskHistory.addTimeRecord(tname, cd);
			}
		}
	}
	
	/**
	 * For debugging purposes, print the current task history to stdout.
	 */
	public void printHistory()
	{
		m_taskHistory.printTaskHistory();
	}

	/**
	 * Testing.
	 * @param args no args.
	 */
	public static void main(String[] args)
	{
		Tk_MainWindow tmw = new Tk_MainWindow();
		//tmw.printHistory();
	}
}
package Tk_Gui;

import java.awt.Component;
import java.awt.event.MouseEvent;

import javax.swing.event.MouseInputListener;

/**
 * A mouse listener for the MyClock class, that allows the clock window to
 * be moved around by the mouse.
 * @author michaelwebster
 *
 */
public class Tk_MouseListener implements MouseInputListener
{
	// The clock whose mouse this listener is registered for. Note also that
	// clock will be used by this listener to reposition the clock window.
	Component m_parent = null;
	
	// parent_x and parent_y are the current screen coordinates of the clock.
	int parent_x = 0;
	int parent_y = 0;
	
	// start_x and start_y are the last coordinates that the mouse was checked
	// at.
	int start_x = 0;
	int start_y = 0;
	
	// move_x and move_y are the relative change in coordinates for the clock
	// that will move it to the indicated mouse position.
	int move_x = 0;
	int move_y = 0;

	public Tk_MouseListener(Component comp)
	{
		m_parent = comp;
		parent_x = comp.getX();
		parent_y = comp.getY();
	}

	@Override
	public void mouseClicked(MouseEvent e)
	{
		// TODO Auto-generated method stub
		return;
	}

	@Override
	public void mousePressed(MouseEvent e)
	{
		start_x = e.getX();
		start_y = e.getY();
	}

	@Override
	public void mouseReleased(MouseEvent e)
	{
		move_x = e.getX() - start_x;
		move_y = e.getY() - start_y;
		parent_x += move_x;
		parent_y += move_y;
		m_parent.setLocation(parent_x, parent_y);
		m_parent.repaint();
	}

	@Override
	public void mouseEntered(MouseEvent e)
	{
		// TODO Auto-generated method stub

	}

	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub

	}

	@Override
	public void mouseDragged(MouseEvent e)
	{
		// TODO Auto-generated method stub
		move_x = e.getX() - start_x;
		move_y = e.getY() - start_y;
		start_x = e.getX();
		start_y = e.getY();
		parent_x += move_x;
		parent_y += move_y;
		m_parent.setLocation(parent_x, parent_y);
		m_parent.repaint();
	}

	@Override
	public void mouseMoved(MouseEvent e) {
		/*move_x = e.getX() - start_x;
		move_y = e.getY() - start_y;
		start_x = e.getX();
		start_y = e.getY();
		parent_x += move_x;
		parent_y += move_y;
		clock.setLocation(parent_x, parent_y);
		clock.invalidate();*/
	}
}
package Tk_Gui;

import javax.swing.*;
import java.awt.event.*;
import java.util.*;
import org.w3c.dom.*;

import Tk_History.Tk_ActiveTimeRecord;

/**
 * A JPanel that contains a Tk_Digital clock that displays task times and
 * durations, and a Tk_ButtonBox containing the "Start Task" and
 * "End Task" buttons.
 *
 * @author michaelwebster
 */
public class Tk_StartDisplay extends JPanel implements ActionListener
{
	// The action commands sent by the "Start Task" and "Stop Task" JButtons.
	public final static String StartCommand			= "start";
	public final static String StopCommand			= "stop";
	
	/**
	 * Clock display for task times, durations and name of current task.
	 */
	private Tk_Digital 			m_clock 			= null;
	
	/**
	 *  Button box containing the start and stop buttons.
	 */
	private Tk_TaskButtonBox	m_switcher			= null;
	
	/**
	 * The name of the current task being timed.
	 */
	private String				m_currentTask		= null;
	
	/**
	 * The name of the task selected in the Tk_TaskSelect combo box.
	 */
	private String				m_selectedTask		= null;
	
	/**
	 * Store task_name as both the current and selected task, and instantiate
	 * and add appropriate listeners to m_clock, and m_switcher.
	 *
	 * @param task_name		The name of the current task selected in the
	 * 						Tk_TaskSelect object's combo box.  
	 */
	Tk_StartDisplay(String task_name)
	{
		m_currentTask = task_name;
		m_selectedTask = task_name;
		m_clock = new Tk_Digital(task_name);
		m_switcher = new Tk_TaskButtonBox();
		m_switcher.getStartButton().setActionCommand(StartCommand);
		m_switcher.getStartButton().addActionListener(this);
		m_switcher.getStopButton().setActionCommand(StopCommand);
		m_switcher.getStopButton().addActionListener(this);
		
		// Set the start and stop buttons enabled as is appropriate for the
		// current state.
		m_switcher.getStartButton().setEnabled(!m_clock.isActive());
		m_switcher.getStopButton().setEnabled(m_clock.isActive());
		add(m_clock.getBox());
		add(m_switcher);
	}

	/**
	 * Handle the Start and Stop button actions, by starting or stopping the
	 * m_clock.
	 */
	@Override
	public void actionPerformed(ActionEvent e)
	{
		if (e.getActionCommand().equals(StartCommand))
		{
			startClock();
		}
		else if (e.getActionCommand().equals(StopCommand))
		{
			stopClock();
		}
	}

	/**
	 * Start the clock. If the selected task does not equal the current task,
	 * then tell m_clock to switch tasks before starting the clock.
	 * 
	 * Disable the Start button and enable the stop button before starting
	 * the clock and returning. 
	 */
	public void startClock()
	{
		if (!m_currentTask.equals(m_selectedTask))
		{
			m_currentTask = m_selectedTask;
			m_clock.switchTasks(m_currentTask);
		}
		m_switcher.getStartButton().setEnabled(false);
		m_switcher.getStopButton().setEnabled(true);
		m_switcher.getStopButton().grabFocus();
		m_clock.startClock();
	}
	
	/**
	 * Disable the Stop button, enable the start button and give it focus, and
	 * stop the clock. 
	 */
	public void stopClock()
	{
		m_switcher.getStartButton().setEnabled(true);
		m_switcher.getStopButton().setEnabled(false);
		m_switcher.getStartButton().grabFocus();
		m_clock.stopClock();
	}
	
	/**
	 * Set the m_selected task, so that when start is clicked, we can determine
	 * if a task switch is required.
	 * 
	 * @param stask		The newly selected Task name for timing, next time we
	 * 					start the clock.
	 */
	public void setSelectedTask(String stask)
	{
		m_selectedTask = stask;
	}

	/**
	 * Get and return the m_clock's time records.
	 *
	 * @return	A mapping between tasknames and Time Record Documents as
	 * 			recorded by the m_clock.
	 */
	public HashMap<String, Vector<Document>>getTimeRecords()
	{
		return m_clock.getTaskMap();
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		JFrame jf = new JFrame("Start Display");
		Date d = new Date();
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTime(d);
		Tk_StartDisplay tsd = new Tk_StartDisplay("Programming");
		jf.add(tsd);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}
}
package Tk_Gui;

import javax.swing.*;
import javax.swing.border.*;

/**
 * Simple box containing two buttons labelled "Start Task" and "Stop Task".
 * These buttons can be obtained through getter methods, and have appropriate
 * listeners added to them.
 *
 * @author michaelwebster
 *
 */
public class Tk_TaskButtonBox extends Box
{
	// Action command strings for the two buttons.
	private final static String StartText 	= "Start Task";
	private final static String StopText	= "Stop Task";
	
	// The start and stop JButtons.
	private JButton m_start 	= null;
	private JButton m_stop		= null;
	
	/**
	 * No argument construtor - just create the buttons, add them to this box,
	 * and create a border around them. Make the buttons the same size.
	 */
	public Tk_TaskButtonBox()
	{
		super(BoxLayout.PAGE_AXIS);
		m_start = new JButton(StartText);
		m_stop = new JButton(StopText);
		m_stop.setPreferredSize(m_start.getPreferredSize());
		m_stop.setMinimumSize(m_start.getMinimumSize());
		m_stop.setMaximumSize(m_start.getMaximumSize());
		add(m_start);
		add(m_stop);
		setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));
	}

	/**
	 * Return the m_start JButton.
	 *
	 * @return The start button.
	 */
	public JButton getStartButton()
	{
		return m_start;
	}
	
	/**
	 * Return the m_stop JButton.
	 *
	 * @return The stop button.
	 */
	public JButton getStopButton()
	{
		return m_stop;
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		JFrame jf = new JFrame("Task Button Box");
		Tk_TaskButtonBox tbb = new Tk_TaskButtonBox();
		
		jf.add(tbb);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}

}
package Tk_Gui;

/**
 * TimeBar Draws a coloured bar of a certain width on a canvas. The following
 * parameters give it the information it needs to do it's job.
 * 
 * 1. An orientation (Horizontal or Vertical)
 * 2. A direction of growth (Up, Down, Left or Right)
 * 3. A colour.
 * 4. An origin point that, depending on the orientation, or dirction of
 *    growth, will be the position of the top left, bottom left, or top right
 *    corner of the bar.
 * 5. The width of the bar,
 * 6. A Graphics2D instance,
 * 7. A minimum and maximum length or height of the bar.
 * 8. A source of events that cause the update of the bar.
 * 9. A relationship between the quantity received in the events and the
 * 	  size to display on screen.
 * 
 * @author michaelwebster
 *
 */
public class Tk_TimeBar
{

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub

	}

}
/**
 * 
 */
/**
 * @author michaelwebster
 *
 */
package Tk_History;package Tk_History;

import javax.swing.Timer;
import java.util.GregorianCalendar;
import java.util.Date;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import org.w3c.dom.*;

/**
 * A Time record with a timer attached to keep the record updated.
 * 
 * @author michaelwebster
  */
public class Tk_ActiveTimeRecord extends Tk_TimeRecord implements ActionListener
{
	private final static int MSEC_DELAY = 1000;
	private Timer m_timer = null;
	private long m_lastEventTime = 0;

	/**
	 * Setup the active timer starting at time = start_time.
	 *
	 * @param start_time	The millisecond valur for the start time.
	 */
	public Tk_ActiveTimeRecord(long start_time)
	{
		super(start_time, start_time, 0);
		m_timer = new Timer(MSEC_DELAY, this);
		m_timer.setInitialDelay(MSEC_DELAY);
		m_timer.setCoalesce(true);
	}

	/**
	 * Start the ActiveTimeRecord running, by starting up the timer.
	 */
	public void startTask()
	{
		assert(m_timer.isRunning() == false);
		Date d = new Date();
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTime(d);
		m_lastEventTime = gc.getTimeInMillis();
		setStartTime(m_lastEventTime);
		setEndTime(m_lastEventTime);
		m_timer.start();
	}
	
	/**
	 * Stop the active time record from running, and record the data for this
	 * run of the time record to an XML document.
	 */
	public void stopTask()
	{
		assert(m_timer.isRunning());
		m_timer.stop();
		serializeToDocument();
	}
	
	/**
	 * Update the appropriate time fields based on the current time, and
	 * notify any observers of the change.
	 */
	@Override
	public void actionPerformed(ActionEvent e)
	{
		if (e.getSource() == m_timer)
		{
			Date d = new Date();
			GregorianCalendar gc = new GregorianCalendar();
			gc.setTime(d);
			setEndTime(gc.getTimeInMillis());
			setChanged();
			notifyObservers();
			clearChanged();
		}
	}

	/**
	 * 
	 * @return
	 */
	public Timer getTimer()
	{
		return m_timer;
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		Date d = new Date();
		System.out.printf("Date is %s\n",d.toString());
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTime(d);
		System.out.printf("gc is now %s\n", gc.getTime().toString());
		System.out.printf("gc is %d\n", gc.getTimeInMillis());
		Tk_ActiveTimeRecord tat = new Tk_ActiveTimeRecord(gc.getTimeInMillis());
		tat.startTask();
		System.out.println("Create Tk_ActiveTimeRecord with:");
		//tat.printTimeRecord();
		
		for (int i = 0; i < 5000; i++)
		{
			try
			{
				Thread.sleep(2010);
			}
			catch (InterruptedException e)
			{
				System.out.println("Got interrupted!");
				System.out.println(e.getMessage());
			}
		}
		tat.stopTask();
	}

}
package Tk_History;

import java.util.*;
import java.net.*;
import java.io.*;
import org.w3c.dom.*;
import org.xml.sax.*;

import Tk_utils.Tk_FileUtil;
import Tk_utils.Tk_XmlUtil;
import javax.xml.parsers.*;
import javax.xml.validation.*;
import javax.xml.datatype.*;
import javax.swing.*;
import Tk_Configuration.Tk_TaskCollection;
import Tk_Configuration.Tk_TaskListModel;

/**
 * Tk_TaskHistory represents
 * @author michaelwebster
 *
 */
public class Tk_TaskHistory
{
	/*
	 * Static xml element strings for a TK_History.xsd format file.
	 */
	private final static String TK_History 			= "TK_History";
	private final static String TK_Task				= "TK_Task";
	public  final static String TK_TimeRecord		= "TK_TimeRecord";
	public  final static String TK_StartTime		= "TK_StartTime";
	public	final static String TK_EndTime			= "TK_EndTime";
	public  final static String TK_ElapsedTime		= "TK_ElapsedTime";
	
	/*
	 * Static xml attribute strings for a TK_History.xsd format file.
	 */
	public 	final static String TK_TaskName 		= "name";
	public 	final static String TK_TotalTime		= "TK_TotalTime";
	
	/**
	 * A map from task names to lists of xml document time records for those
	 * tasks.
	 */
	private HashMap<String, Vector<Document>>m_taskHistory = null;
	
	/*
	 * Instance attributes.
	 */
	private String 				m_xmlFileName			= null;
	private String				m_schemaFileName		= null;
	private Document			m_doc					= null;

	public Tk_TaskHistory(String xml_fname, String xsd_fname)
	{
		/*
		 * Create the URI for the xml task list from the supplied uri_string.
		 */
		m_xmlFileName = xml_fname;
		m_schemaFileName = xsd_fname;
		m_doc = Tk_XmlUtil.createDocument(m_xmlFileName, m_schemaFileName);
		
		m_taskHistory = readHistory();
		printTaskHistory();
	}

	/**
	 * Read in the task history from the TK_History.xml file, and store it in
	 * a HashMap map.
	 *
	 * @return The HashMap mapping between task names and lists of documents.
	 */
	public HashMap<String, Vector<Document>>readHistory()
	{
		HashMap<String, Vector<Document>> hist = null;
		hist = new HashMap<String, Vector<Document>>();
		assert(m_doc != null);
		Element el = m_doc.getDocumentElement();

		if (null != el)
		{
			System.out.printf("el is %s\n", el.getLocalName());
		}
		else
		{
			System.out.println("Horrible error: el is null.");
		}
		
		if (null != el)
		{
			NodeList task_nodes = el.getElementsByTagName(TK_Task);
			for (int i = 0; i < task_nodes.getLength(); i++)
			{
				Element task = (Element)task_nodes.item(i);
				String task_name = task.getAttribute(TK_TaskName);
				//System.out.printf("Got task named: %s\n", task_name);
				Vector<Document>vd = null;
				if (!hist.containsKey(task_name))
				{
					//System.out.printf("Creating Vector for: %s\n", task_name);
					vd = new Vector<Document>();
					hist.put(task_name, vd);
				}
				else
				{
					//System.out.printf("Found Vector for: %s\n", task_name);
					vd = hist.get(task_name);
				}
				
				Tk_TimeRecord tr = new Tk_TimeRecord();				
				NodeList record_nodes = task.getElementsByTagName(TK_TimeRecord);
				for (int j = 0; j < record_nodes.getLength(); j++)
				{
					Element record_el = (Element)record_nodes.item(j);
					Element elt = Tk_XmlUtil.getFirstElement(record_el, TK_StartTime);
					String start_time = Tk_XmlUtil.getSimpleElementText(elt);
					elt = Tk_XmlUtil.getFirstElement(record_el, TK_EndTime);
					String end_time = Tk_XmlUtil.getSimpleElementText(elt);
					elt = Tk_XmlUtil.getFirstElement(record_el, TK_ElapsedTime);
					String duration = Tk_XmlUtil.getSimpleElementText(elt);
					tr.setFromStrings(start_time, end_time, duration);
					tr.serializeToDocument();
					Document tr_doc = tr.getXMLDocument();
					vd.add(tr_doc);
				}
			}
		}
		return hist;
	}

	/**
	 * Rewrite the Task list into the DOM, and write the DOM back to the
	 * TK_History.xml file.
	 */
	public void updateDom()
	{
		Document doc = Tk_XmlUtil.createEmptyDom(m_schemaFileName);

		Node root = doc.createElement(TK_History);
		doc.appendChild(root);
		addElements(doc, root, m_taskHistory);
		m_doc = doc;
		writeBackDom();
	}
	
	/**
	 * Add each of the entries in the HashMap to the DOM in doc, rooted at
	 * "root".
	 *
	 * @param doc		The DOM document to be filled out.
	 * @param root		The TK_History element root of the DOM document.
	 * @param docs		A hash map of the records to be poked into the DOM.
	 */
	private void addElements
	(
		Document doc,
		Node root,
		HashMap<String, Vector<Document>>docs
	)
	{
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord(long, long, long) constructor."
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}

		Iterator<String>it = docs.keySet().iterator();
		while (it.hasNext())
		{
			String tname = it.next();
			Element ctask = doc.createElement(TK_Task);
			root.appendChild(ctask);
			ctask.setAttribute(TK_TaskName, tname);
			Iterator <Document>d_it = docs.get(tname).iterator();
			Duration duration = dtf.newDuration(0);
			while (d_it.hasNext())
			{
				Document d = d_it.next();
				Element rec_el = d.getDocumentElement();
				Element start_time = Tk_XmlUtil.getFirstElement(rec_el, TK_StartTime);
				String st = Tk_XmlUtil.getSimpleElementText(start_time);
				Element end_time = Tk_XmlUtil.getFirstElement(rec_el, TK_EndTime);
				String et = Tk_XmlUtil.getSimpleElementText(end_time);
				Element dur_el = Tk_XmlUtil.getFirstElement(rec_el, TK_ElapsedTime);
				String dur_string = Tk_XmlUtil.getSimpleElementText(dur_el);
				duration = duration.add(dtf.newDuration(dur_string));
				Element trec = doc.createElement(TK_TimeRecord);
				ctask.appendChild(trec);
				Element s_rec = doc.createElement(TK_StartTime);
				trec.appendChild(s_rec);
				s_rec.appendChild(doc.createTextNode(st));
				Element e_rec = doc.createElement(TK_EndTime);
				trec.appendChild(e_rec);
				e_rec.appendChild(doc.createTextNode(et));
				Element d_rec = doc.createElement(TK_ElapsedTime);
				trec.appendChild(d_rec);
				d_rec.appendChild(doc.createTextNode(dur_string));
			}
			ctask.setAttribute(TK_TotalTime, duration.toString());
		}
	}

	/**
	 * Write the DOM back to a temporary file.
	 */
	private void writeBackDomTemp()
	{
		int last_slash = m_xmlFileName.lastIndexOf('/');
		String xml_path = m_xmlFileName.substring(0, last_slash);
		try
		{
			File xml_dir = new File(xml_path);
			File xml_file = File.createTempFile("TK_History", ".xml", xml_dir);
			FileWriter fw = new FileWriter(xml_file);
			fw.write(Tk_XmlUtil.formatDoc(m_doc));
			fw.close();
		}
		catch (IOException e)
		{
			System.out.println("Tk_TaskHistory: writeBackDom IOException.");
			System.out.println(e.getMessage());
			System.exit(-1);
		}
	}
	
	/**
	 * Write the DOM back to the task list xml file. 
	 */
	private void writeBackDom()
	{
		try
		{
			File xml_file = new File(m_xmlFileName);
			FileWriter fw = new FileWriter(xml_file);
			fw.write(Tk_XmlUtil.formatDoc(m_doc));
			fw.close();
		}
		catch (IOException e)
		{
			System.out.println("Tk_TaskHistory: writeBackDom IOException.");
			System.out.println(e.getMessage());
			System.exit(-1);
		}
	}
	
	/**
	 * Get the task history for the given task name.
	 *
	 * @param task_name		The name of the task we want to extract history
	 * 						for.
	 *
	 * @return 	A Vector of dom documents representing the history of this
	 * 			task.
	 */
	private Vector<Document>getTaskHistory(String task_name)
	{
		assert(this.m_taskHistory != null);
		if (m_taskHistory.containsKey(task_name))
		{
			return m_taskHistory.get(task_name);
		}
		else
		{
			return null;
		}
	}
	
	/**
	 * Return a sorted map (TreeMap) between dates and vectors of time records
	 * for tasks that have been performed on those dates.
	 *
	 * @param task_name	The name of the task to be processed.
	 *
	 * @return	A sorted map from GregorianCalendar representations of days
	 * 			that a task has run, to a Vector of times for each of those
	 * 			days.
	 */
	public TreeMap<GregorianCalendar, Vector<Tk_TimeRecord>>getTaskMap(String task_name)
	{
		TreeMap<GregorianCalendar, Vector<Tk_TimeRecord>> tm =
			new TreeMap<GregorianCalendar, Vector<Tk_TimeRecord>>();
		
		Vector<Document> vd = getTaskHistory(task_name);
		if (vd == null)
		{
			return null;
		}
		
		Iterator<Document>dit = vd.iterator();
		while (dit.hasNext())
		{
			Document d = dit.next();
			Element el = d.getDocumentElement();
			Tk_TimeRecord nr = new Tk_TimeRecord(el);
			GregorianCalendar gc = nr.getStartDate();
			if (!tm.containsKey(gc))
			{
				tm.put(gc, new Vector<Tk_TimeRecord>());
			}
			tm.get(gc).add(nr);
		}
		return tm;
	}

	/**
	 * Get the task history.
	 *
	 * @return The HashMap containing the task history.
	 */
	public HashMap<String, Vector<Document>> getHistory()
	{
		assert(this.m_taskHistory != null);
		return m_taskHistory;
	}
	
	/**
	 * Add the document doc into a vector in the m_taskHistory map with the
	 * key given by task_name.
	 * 
	 * @param task_name		Key for recording this time record.
	 * @param doc			The document to be recorded under key = task_name.
	 */
	public void addTimeRecord(String task_name, Document doc)
	{
		Vector<Document>vd = null;
		if 
		(
			!m_taskHistory.containsKey(task_name)
			||
			m_taskHistory.get(task_name) == null
		)
		{
			//System.out.printf("Creating Vector for: %s\n", task_name);
			vd = new Vector<Document>();
			m_taskHistory.put(task_name, vd);
		}
		else
		{
			//System.out.printf("Found Vector for: %s\n", task_name);
			vd = m_taskHistory.get(task_name);
		}
		vd.add(doc);
	}

	/**
	 * Just print the task history.
	 */
	public void printTaskHistory()
	{
		Iterator<String>it = m_taskHistory.keySet().iterator();
		while (it.hasNext())
		{
			String tname = it.next();
			Vector<Document>docs = m_taskHistory.get(tname);
			System.out.printf
			(
				"\n\n<<<<<<<<<<<<<<< Task = (%s) >>>>>>>>>>>>\n",
				tname
			);
			for (int i = 0; i < docs.size(); i++)
			{
				Document cd = docs.elementAt(i);
				String trec = Tk_XmlUtil.formatDoc(cd);
				System.out.println("Xml our from serialize to node is:");
				System.out.printf("%s", trec);
			}
		}
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		String home = System.getProperty("user.home");
		String tk_dir = home.concat(Tk_FileUtil.Tk_XmlDir);
		String xml_file = tk_dir.concat(File.separator + "TK_History.xml");
		String xsd_file = tk_dir.concat(File.separator + "TK_History.xsd");
		System.out.printf("xml file is:\n%s\n", xml_file);
		System.out.printf("xsdl file is:\n%s\n", xml_file);
		Tk_TaskHistory th = new Tk_TaskHistory(xml_file, xsd_file);
		//th.readCurrentHistory();
		System.out.println("\n\n<<<<<<<<<<<<<<<<< Task History >>>>>>>>>>>>>>>>>>>>>\n\n");
		th.printTaskHistory();
		
		String[] tasks =
			{
				"Job Search",
				"Java FX for time keeper visualisation",
				"Sleeping",
				"Sudoku creater",
				"Bar graph widget",
				"watching tv",
				"Ios 7 lectures CS 193p"
			};
		
		for (int i = 0; i < tasks.length; i++)
		{
			TreeMap<GregorianCalendar, Vector<Tk_TimeRecord>>gt = 
				th.getTaskMap(tasks[i]);
			System.out.printf
			(
				"Times by day for task ========== %s ===========\n",
				tasks[i]
			);
			
			Iterator<GregorianCalendar>gcit = gt.keySet().iterator();
			while (gcit.hasNext())
			{
				GregorianCalendar gc = gcit.next();
				System.out.printf("Tasks for %s on day = %d %d %d\n", 
						tasks[i],
						gc.get(Calendar.YEAR),
						gc.get(Calendar.MONTH),
						gc.get(Calendar.DAY_OF_MONTH)
				);
				Vector<Tk_TimeRecord>ttr = gt.get(gc);				
				Iterator<Tk_TimeRecord>trit = ttr.iterator();
				while (trit.hasNext())
				{
					Tk_TimeRecord tktr = trit.next();
					System.out.printf("StartTime(%s) EndTime(%s)\n",
							tktr.getStartTime(),
							tktr.getEndTime()
							);
				}
			}
			
		}
	}

}
package Tk_History;

import java.util.*;
import org.w3c.dom.*;
import javax.xml.datatype.*;
import Tk_History.Tk_TaskHistory;
import Tk_utils.Tk_XmlUtil;

/**
 * Tk_TimeRecord represents the start time, end time and duration of a task.
 *
 * @author michaelwebster
 */
public class Tk_TimeRecord extends Observable
{
	/**
	 * Time the Start Task button was last pressed.
	 */
	protected XMLGregorianCalendar m_start		= null;
	
	/**
	 * The current time, or if the Stop Task button has been pressed, the end
	 * time.
	 */
	protected XMLGregorianCalendar m_end		= null;
	
	/**
	 * The Duration between m_start and m_end.
	 */
	protected Duration m_duration				= null;
	
	/**
	 * The XML DOM element that represents this current time record once it
	 * has completed.
	 */
	private Document m_doc						= null;



	/**
	 * Create a new empty <code>Tk_TimeRecord</code>
	 */
	public Tk_TimeRecord()
	{
		// Do nothing.
	}

	/**
	 * Create the Tk_Time Record with millisecond values for the start and
	 * end times of the Time Record. The duration is given as e - s.
	 * 
	 * @param s	Start Time in ms since the epoch.
	 * @param e End Time in ms since the epoch.
	 * @throws IllegalArgumentException
	 */
	public Tk_TimeRecord(long s, long e)
			throws IllegalArgumentException
	{
		this(s, e, e - s);
	}

	/**
	 * Create a Tk_TimeRecord with millisecond values for the start and end
	 * times, and the duration.
	 * 
	 * Throw Illegal argument exception if d != (e - s).
	 *
	 * @param s	Start Time in ms since the epoch.
	 * @param e End Time in ms since the epoch.
	 * @param d Millisecond value for duration - must equal (e - s).
	 * @throws IllegalArgumentException
	 */
	public Tk_TimeRecord(long s, long e, long d) 
			throws IllegalArgumentException
	{
		if (d != (e -s))
		{
			String err_string = null;
			err_string = String.format
				(
					"Error in %s.\n d(%d) must equal e(%d) - s(%d)\n",
					"Tk_TimeRecord(long s, long e, long d)",
					d,
					e,
					s
				);
			IllegalArgumentException err = new IllegalArgumentException(err_string);
			throw(err);
		}
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord(long, long, long) constructor."
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}

		// Create a Gregorian calendar to set the dates in the
		// XMLGregorianCalendars.
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(s);
		m_start = dtf.newXMLGregorianCalendar(gc);
		
		gc.setTimeInMillis(e);
		m_end = dtf.newXMLGregorianCalendar(gc);
		
		m_duration = dtf.newDuration(d);
	}

	/**
	 * Create a Tk_TimeRecord from xml lexicial dateTime format strings and
	 * an xml lexical duration string.
	 *
	 * @param s xml lexical dateTime string for start time.
	 * @param e xml lexical dateTime string for start time.
	 * @param d xml lexical duration string for duration.
	 */
	public Tk_TimeRecord(String s, String e, String d)
	{
		setFromStrings(s, e, d);
	}
	
	/**
	 * Create a Tk_TimeRecord from a DOM TimeRecord node. If the supplied node
	 * is not a TK_TimeRecord node, throw an IllegalArgumentException.
	 *
	 * @param n	A TK_TimeRecord DOM node.
	 * @throws IllegalArgumentException
	 */
	public Tk_TimeRecord(Node n) throws IllegalArgumentException
	{
		String lname = n.getNodeName();		//n.getLocalName();
		if (!lname.equals(Tk_TaskHistory.TK_TimeRecord))
		{
			String e_string = new String("");
			e_string = "Error: Tk_TimeRecrod(Node n) constructor.\n";
			e_string += "Expected a " + Tk_TaskHistory.TK_TimeRecord;
			e_string += " but got a: " + lname + " element\n";
			IllegalArgumentException e =
				new IllegalArgumentException
				(
					e_string
				);
			throw(e);
		}
		
		String s = Tk_utils.Tk_XmlUtil.getSimpleElementText
				(
					(Element)n,
					Tk_TaskHistory.TK_StartTime
				);
		String e = Tk_utils.Tk_XmlUtil.getSimpleElementText
				(
					(Element)n,
					Tk_TaskHistory.TK_EndTime
				);
		String d = Tk_utils.Tk_XmlUtil.getSimpleElementText
				(
					(Element)n,
					Tk_TaskHistory.TK_ElapsedTime
				);
		
		setFromStrings(s, e, d);
	}

	/**
	 * Serialize the current time record to an xml element, and return it.
	 *
	 * @return A DOM TK_TimeRecord element.
	 */
	protected void serializeToDocument()
	{
		m_doc = Tk_XmlUtil.createEmptyDom();
		Element root = m_doc.createElement(Tk_TaskHistory.TK_TimeRecord);
		//root.setAttribute(Tk_TaskHistory.TK_IsCurrent, "false");
		m_doc.appendChild(root);
		Element start_time = m_doc.createElement(Tk_TaskHistory.TK_StartTime);
		start_time.appendChild(m_doc.createTextNode(getXMLStartTime()));
		Element end_time = m_doc.createElement(Tk_TaskHistory.TK_EndTime);
		end_time.appendChild(m_doc.createTextNode(getXMLEndTime()));
		Element elapsed_time = m_doc.createElement(Tk_TaskHistory.TK_ElapsedTime);
		elapsed_time.appendChild(m_doc.createTextNode(getXMLDuration()));
		root.appendChild(start_time);
		root.appendChild(end_time);
		root.appendChild(elapsed_time);
	}
	
	/**
	 * Return the xml DOM element created to record thie completed time record.
	 * @return
	 */
	public Document getXMLDocument()
	{
		return m_doc;
	}

	/**
	 * Set the Tk_TimeRecord start, end and duration fields from xml lexical
	 * strings s, e, and d respectively.
	 *
	 * @param s xml lexical timeDate string for the task start time.
	 * @param e xml lexical timeDate string for the end time.
	 * @param d xml lexical duration string for the task duration.
	 */
	public void setFromStrings(String s, String e, String d)
	{
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord(long, long, long) constructor."
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}

		m_start = dtf.newXMLGregorianCalendar(s);
		m_end = dtf.newXMLGregorianCalendar(e);
		m_duration = dtf.newDuration(d);		
	}

	/**
	 * Set the value of the m_start field from the supplied ms value.
	 *
	 * @param ms 	The number of milliseconds from the epoch to the start time
	 * 				of this task.
	 */
	protected void setStartTime(long ms)
	{
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(ms);
		m_start.setTime
		(
			gc.get(Calendar.HOUR_OF_DAY),
			gc.get(Calendar.MINUTE),
			gc.get(Calendar.SECOND),
			gc.get(Calendar.MILLISECOND)
		);
		m_start.setDay(gc.get(Calendar.DAY_OF_MONTH));
		m_start.setMonth(gc.get(Calendar.MONTH) + 1);
		m_start.setYear(gc.get(Calendar.YEAR));
	}

	/**
	 * Set the end time or current time for this task. As a side effect, also
	 * set the duration of this task as the difference between the start and
	 * end times.
	 *
	 * @param ms	The number of since the epoch until now, or until the task
	 * 				was stopped.
	 */
	protected void setEndTime(long ms)
	{
		GregorianCalendar gc_end = new GregorianCalendar();
		gc_end.setTimeInMillis(ms);
		m_end.setTime
		(
			gc_end.get(Calendar.HOUR_OF_DAY),
			gc_end.get(Calendar.MINUTE),
			gc_end.get(Calendar.SECOND),
			gc_end.get(Calendar.MILLISECOND)
		);
		m_end.setDay(gc_end.get(Calendar.DAY_OF_MONTH));
		m_end.setMonth(gc_end.get(Calendar.MONTH) + 1);
		m_end.setYear(gc_end.get(Calendar.YEAR));
		
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord.setEndTime(long)"
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}
		GregorianCalendar gc_start = m_start.toGregorianCalendar();
		m_duration = dtf.newDuration(gc_end.getTimeInMillis() - gc_start.getTimeInMillis());
	}

	/**
	 * Add the supplied millisecond value to the duration.
	 *
	 * @param ms	A millisecond value indicating a duration.
	 */
	protected void addToDuration(long ms)
	{
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord.setEndTime(long)"
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}
		Duration d = dtf.newDuration(ms);
		m_duration = m_duration.add(d);
		m_end.add(d);
	}

	/**
	 * Return a human readable string for this task's start time.
	 *
	 * @return A human readable string for the start time.
	 */
	public String getStartTime()
	{
		GregorianCalendar cal = m_start.toGregorianCalendar();
		return cal.getTime().toString();
	}
	
	/**
	 * Return the Start time as a lexical xml dateTime string.
	 * 
	 * @return	lexical xml dateTime string for the task's start time.
	 */
	public String getXMLStartTime()
	{
		return m_start.toXMLFormat();
	}
	
	/**
	 * Return the Date this task started.
	 *
	 * @return	The gregorian calendar representation of the start time of
	 * 			the task, with all the hours, minutes and seconds zeroed.
	 */
	public GregorianCalendar getStartDate()
	{
		GregorianCalendar g = m_start.toGregorianCalendar();
		g.clear(Calendar.HOUR_OF_DAY);
		g.clear(Calendar.MINUTE);
		g.clear(Calendar.SECOND);
		g.clear(Calendar.HOUR);
		g.clear(Calendar.MILLISECOND);
		return g;
	}
	
	/**
	 * Return a human readable string for this task's end time.
	 *
	 * @return A human readable string for the end time.
	 */
	public String getEndTime()
	{
		GregorianCalendar cal = m_end.toGregorianCalendar();
		return cal.getTime().toString();
	}

	/**
	 * Return the end time as a lexical xml dateTime string.
	 * 
	 * @return	lexical xml dateTime string for the task's end time.
	 */
	public String getXMLEndTime()
	{
		return m_end.toXMLFormat();
	}

	/**
	 * Return the Date this task ended.
	 *
	 * @return	The gregorian calendar representation of the end time of
	 * 			the task, with all the hours, minutes and seconds zeroed.
	 */
	public GregorianCalendar getEndDate()
	{
		GregorianCalendar g = m_end.toGregorianCalendar();
		g.clear(GregorianCalendar.HOUR_OF_DAY);
		g.clear(GregorianCalendar.MINUTE);
		g.clear(GregorianCalendar.SECOND);
		g.clear(Calendar.HOUR);
		g.clear(Calendar.MILLISECOND);
		return g;
	}

	/**
	 * Return a human readable duration string.
	 * 
	 * @return Human readable duration string.
	 */
	public String getDuration()
	{
		String dur = String.format
		(
			"%02d:%02d:%02d",
			m_duration.getHours(),
			m_duration.getMinutes(),
			m_duration.getSeconds()
		);
		return dur;
	}


	/**
	 * Return the duration as a lexical xml duration string.
	 * 
	 * @return	lexical xml duration string for the task's duration.
	 */
	public String getXMLDuration()
	{
		return m_duration.toString();
	}
	
	/**
	 * Return the m_duration field.
	 *
	 * @return	the m_duration Duration attribute.
	 */
	public Duration getCurrentDuration()
	{
		return m_duration;
	}
	
	public static Duration normalizeDuration(Duration d)
	{
		int secs = d.getSeconds();
		int mins = d.getMinutes();
		int hours = d.getHours();
			
		int final_secs =  secs % 60;
		int extra_min = secs / 60;
		int tm = mins + extra_min;
		int final_mins = tm % 60;
		int extra_hour = tm / 60;
		int final_hours = hours + extra_hour;
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_TimeRecord(long, long, long) constructor."
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}
		return dtf.newDuration(true, 0, 0, 0, final_hours, final_mins, final_secs);

	}

	/**
	 * Print the timeRecord to stdout. For debugging.
	 */
	public void printTimeRecord()
	{
		System.out.printf("Start Time = %s\n", getStartTime());
		System.out.printf("End Time = %s\n", getEndTime());
		System.out.printf("Duration = %s\n", getDuration());
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		GregorianCalendar cal1 = new GregorianCalendar(); //Calendar.getInstance();
		cal1.set(2015, 11, 15, 18, 01, 33);
		GregorianCalendar cal2 = new GregorianCalendar(); //Calendar.getInstance();
		cal2.set(2016, 01, 15, 12, 30, 45);
		Tk_TimeRecord tr = new Tk_TimeRecord
			(
				cal1.getTimeInMillis(),
				cal2.getTimeInMillis(),
				cal2.getTimeInMillis() - cal1.getTimeInMillis()
			);
		
		System.out.println("TimerRecord.");
		System.out.printf("StartTime = %s\n", tr.getStartTime());
		System.out.printf("EndTime = %s\n", tr.getEndTime());
		System.out.printf("Duration = %s\n", tr.getDuration());
		
		Tk_TimeRecord tr1 = new Tk_TimeRecord
				(
					cal1.getTimeInMillis(),
					cal2.getTimeInMillis()
				);
			
		System.out.println("TimerRecord.");
		System.out.printf("StartTime = %s\n", tr1.getStartTime());
		System.out.printf("EndTime = %s\n", tr1.getEndTime());
		System.out.printf("Duration = %s\n", tr1.getDuration());
		
		System.out.println("TimerRecord in XML format.");
		System.out.printf("StartTime = %s\n", tr1.getXMLStartTime());
		System.out.printf("EndTime = %s\n", tr1.getXMLEndTime());
		System.out.printf("Duration = %s\n", tr1.getXMLDuration());
		
		Tk_TimeRecord tr2 = new Tk_TimeRecord
				(
					tr1.getXMLStartTime(),
					tr1.getXMLEndTime(),
					tr1.getXMLDuration()
				);
		System.out.println("TimerRecord from lexical strings.");
		System.out.printf("StartTime = %s\n", tr2.getStartTime());
		System.out.printf("EndTime = %s\n", tr2.getEndTime());
		System.out.printf("Duration = %s\n", tr2.getDuration());
		
		System.out.println("TimerRecord from lexical strings in XML format.");
		System.out.printf("StartTime = %s\n", tr2.getXMLStartTime());
		System.out.printf("EndTime = %s\n", tr2.getXMLEndTime());
		System.out.printf("Duration = %s\n", tr2.getXMLDuration());
		
		GregorianCalendar gc = tr2.getStartDate();
		System.out.printf("Start DATE is: %s %s %s : %s:%s:%s\n",
				gc.get(Calendar.YEAR),
				gc.get(Calendar.MONTH),
				gc.get(Calendar.DAY_OF_MONTH),
				gc.get(Calendar.HOUR),
				gc.get(Calendar.MINUTE),
				gc.get(Calendar.SECOND)
				);
	}

}
/**
 * 
 */
/**
 * @author michaelwebster
 *
 */
package Tk_TaskSelectPanel;package Tk_TaskSelectPanel;

import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.border.BevelBorder;

import Tk_Configuration.Tk_TaskCollection;

/**
 * TkAdditional Tasks is a panel for the right hand side of the Edit Tasks
 * dialog. It contains:
 * - A scrollable JList that displays the Additional Tasks
 * - A JTextBox that is used to input new tasks to be added.
 * - An AddTask Button to add the task in the textbox to the Additional Tasks
 * JList.
 * - A RemoveTask Button to remove the item selected in the Additional Tasks
 * JList from that JList and it's underlying model.
 * 
 * The class is constructed by supplying two DefaultComboBoxModel instances
 * containing the retired tasks that are displayed in the Additional Tasks
 * JList, and the deleted tasks that are not displayed.
 * @author michaelwebster
 *
 */
public class Tk_AdditionalTasks extends JPanel implements ListSelectionListener
{
	//
	// ActionCommand strings for the Add Task button, the Remove Task button
	// and the Enter Key pressed in the m_addText JTextField.
	//
	private static final String AddString 		= "Add";
	private static final String DeleteString 	= "Delete";
	private static final String EnterString 	= "Enter";

	
	JList<String>					m_retiredTasks 	= null;
	DefaultComboBoxModel<String>    m_listModel     = null;
	DefaultComboBoxModel<String>	m_deletedTasks	= null;
	JScrollPane     				m_sPane			= null;
	Box			    				m_buttonBox		= null;
	JButton							m_addTask		= null;
	JButton							m_removeTask	= null;
	JTextField						m_addText		= null;
	
	private Vector<String>m_addedTasks 		= new Vector<String>();
	private Vector<String>m_removedTasks 	= new Vector<String>();
	
	/**
	 * Create the Tk_AddtionalTasks object with the AdditionalTasks JList
	 * populated from the retTasks DefaultComboBoxModel parameter.
	 *
	 * @param retTasks   A DefaultComboBoxModel that lists the Tasks that
	 * 					 are currently in the retired state.
	 * @param delTasks   A DefaultComboBoxModel that lists the Tasks that
	 * 					 are currently in the deleted state.
	 */
	public Tk_AdditionalTasks
	(
		DefaultComboBoxModel<String> retTasks,
		DefaultComboBoxModel<String> delTasks
	)
	{
		m_listModel = retTasks;
		m_deletedTasks = delTasks;
		
		//
		// Create the JList and add the m_retiredTasks model to it for display
		// of the retired tasks.
		//
		m_retiredTasks = new JList<String>();
		m_retiredTasks.setModel(m_listModel);
		
		// Make this object a listener for selection events from the JList.
		m_retiredTasks.addListSelectionListener(this);
		
		// Create a scrollable pane to place the m_retiredTasks JList into.
		m_sPane = new JScrollPane();
		m_sPane.getViewport().add(m_retiredTasks);
		
		// Create the "Add Task" button, and set it to be disabled.
		m_addTask = new JButton("Add Task");
		m_addTask.setActionCommand(AddString);
		m_addTask.setEnabled(false);
		
		// Create the "Remove Task" button and set it enabled if there are
		// any Tasks in the list.
		m_removeTask = new JButton("Remove Task");
		m_removeTask.setActionCommand(DeleteString);
		if (m_listModel.getSize() > 0)
		{
			m_retiredTasks.setSelectedIndex(0);
			m_removeTask.setEnabled(true);
		}
		else
		{
			m_removeTask.setEnabled(false);
		}
		
		// Create the m_addText JTextField for adding new tasks.
		m_addText = new JTextField(20);
		m_addText.setActionCommand(EnterString);
		
		// Create the Listener object for handling actions from the two buttons
		// and the JTextField, as well as handling Document Events from the
		// JTextField.
		AddListener addListener = new AddListener(m_addTask);
		m_addTask.addActionListener(addListener);
		m_removeTask.addActionListener(addListener);
		m_addText.addActionListener(addListener);
		m_addText.getDocument().addDocumentListener(addListener);
		
		// Add a Box container for the "Add Task" and "Remove Task" buttons,
		// and lay them out horizonally.
		m_buttonBox = new Box(BoxLayout.X_AXIS);
		m_buttonBox.add(m_addTask);
		m_buttonBox.add(m_removeTask);

		// Layout this Container as a Box with Vertical layout.
		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		
		// Add the components to this container.
		add(m_sPane);
		add(m_addText);
		add(m_buttonBox);
		
		// Set this Container's border.
		setBorder
		(
			BorderFactory.createTitledBorder
			(
				BorderFactory.createBevelBorder(BevelBorder.LOWERED),
				"Additional Tasks:"
			)
		);
	}
	
	JList<String> getRetiredTasks()
	{
		return m_retiredTasks;
	}
	
	/**
	 * This listener implements ActionListener and DocumentListener.
	 *
	 * The ActionListener is shared by the m_addText field and the m_addTask
	 * and m_removeTask JButtons.
	 * 
	 * The DocumentListener is used to pick up changes in the contents of
	 * the m_AddText JTextBox.
	 * 
	 * The following action commands are handled:
	 * - AddString:    	Received from the m_addTask button. The action is to
	 * 					add the string in the m_addText JTextField to the
	 * 					m_retiredTasks JList model.
	 * - DeleteString:	Received from the m_removeTask button. The action is to
	 * 					remove the currently selected item from the
	 * 					m_retiredTasks JList model, and add it to the
	 * 					m_deletedTasks model.
	 * - EnterString:   Received from the m_addText field when Enter is
	 * 					pressed. The action is to add the string in the
	 * 					m_addText JTextField to the m_retiredTasks JList model.
	 * 
	 * Upon receipt of a DocumentEvent, the m_addTask button is enabled or
	 * disabled according to whether there is text in the m_addText
	 * JTextField, or if it is empty.
	 * 
	 * @author michaelwebster
	 *
	 */
    class AddListener implements ActionListener, DocumentListener
    {
        private boolean alreadyEnabled = false;
        private JButton addButton;
       
        /**
         * Set the addButton attribute from the supplied JButton. This button
         * will be enabled or disabled depending on whether the Document in the
         * JTextField contains any text.
         * 
         * @param ab	The "Add Task" button instance.
         */
        public AddListener(JButton ab)
        {
            this.addButton = ab;
        }

        /**
         * Required by ActionListener interface. This method handles the
         * AddString, EnterString and DeleteString action commands that may
         * be received from the "Add Task" button, the "Remove Task" button
         * or the m_add
         * 
         *  @param e    The ActionEvent to be handled.
         */
        public void actionPerformed(ActionEvent e)
        {
        	if 
        	(
        		e.getActionCommand().equals(AddString)
        		||
        		e.getActionCommand().equals(EnterString)
        	)
        	{
        		String name = m_addText.getText();

        		//User didn't type in a unique name...
        		if (name.equals("") || alreadyInList(name))
        		{
        			Toolkit.getDefaultToolkit().beep();
        			m_addText.requestFocusInWindow();
        			m_addText.selectAll();
        			return;
        		}

        		int index = m_retiredTasks.getSelectedIndex(); //get selected index
        		if (index == -1)
        		{
        			//no selection, so insert at beginning
        			index = 0;
        		}
        		else
        		{           //add after the selected item
        			index++;
        		}

        		//m_listModel.insertElementAt(name, index);
        		m_listModel.insertElementAt(name, index);

        		//If we just wanted to add to the end, we'd do this:
        		//listModel.addElement(employeeName.getText());
        		//Reset the text field.
        		m_addText.requestFocusInWindow();
        		m_addText.selectAll();
        		//m_addText.setText("");

        		//Select the new item and make it visible.
        		m_retiredTasks.setSelectedIndex(index);
        		m_retiredTasks.ensureIndexIsVisible(index);
        		
        		m_addedTasks.add(name);
        	}
        	else if (e.getActionCommand().equals(DeleteString))
        	{
        		int index = m_retiredTasks.getSelectedIndex(); //get selected index
        		if (index == -1)
        		{
        			//no selection <= This shouldn't happen...
        			Toolkit.getDefaultToolkit().beep();
        			return;
        		}
        		else
        		{           //add after the selected item
        			String delEl = m_listModel.getElementAt(index);
        			m_listModel.removeElementAt(index);
        			m_deletedTasks.addElement(delEl);
        			if (m_listModel.getSize() == index)
        			{
        				index--;
        			}
        			m_retiredTasks.setSelectedIndex(index);
        			m_retiredTasks.ensureIndexIsVisible(index);
        			m_removedTasks.add(delEl);
        		}
        	}
        }
        
        
        //This method tests for string equality. You could certainly
        //get more sophisticated about the algorithm.  For example,
        //you might want to ignore white space and capitalization.
        /**
         * Check if the String name is already in the m_listModel.
         *
         * @param name	A candidate string for addition to the JList.
         *
         * @return 	true  => name is already in m_listModel - don't add it.
         * 			false => name is not in m_listModel - ok. to add.
         */
        protected boolean alreadyInList(String name)
        {
        	for (int i = 0; i < m_listModel.getSize(); i++)
        	{
        		if (name.equals(m_listModel.getElementAt(i)))
        		{
        			return true;
        		}
        	}
        	return false;
        }

        //Required by DocumentListener.
        /**
         * The document has been inserted to. The "Add Task" button should
         * now be enabled.
         * 
         * @param e		The DocumentEvent sent from the m_addText JTextField.
         */
        public void insertUpdate(DocumentEvent e)
        {
            enableAddButton();
        }

        //Required by DocumentListener.
        /**
         * The document has had content removed. Disable the the "Add Task"
         * button if the Document is now empty.
         * 
         * @param e		The DocumentEvent sent from the m_addText JTextField.
         */
        public void removeUpdate(DocumentEvent e)
        {
            handleEmptyTextField(e);
        }

        //Required by DocumentListener.
        /**
         * The document has had content changed in some way. Disable, or enable
         * the the "Add Task" button depending on whether the Document is 
         * empty or not.
         * 
         * @param e		The DocumentEvent sent from the m_addText JTextField.
         */        
        public void changedUpdate(DocumentEvent e)
        {
            if (!handleEmptyTextField(e))
            {
                enableAddButton();
            }
        }

        /**
         * Enable the "Add Task" button if it has not already been enabled.
         */
        private void enableAddButton()
        {
            if (!alreadyEnabled)
            {
                addButton.setEnabled(true);
                alreadyEnabled = true;
            }
        }

        /**
         * Disable the "Add Task" button if the Document is empty.
         *
         * @param e		The Document Event.
         * @return		true => the Document in the m_addTextField, is empty.
         *				false => the Document is not empty.
         */
        private boolean handleEmptyTextField(DocumentEvent e)
        {
            if (e.getDocument().getLength() <= 0)
            {
                addButton.setEnabled(false);
                alreadyEnabled = false;
                return true;
            }
            return false;
        }
    }

    //This method is required by ListSelectionListener.
    /**
     * Disable or enable the "Remove Task" button, depending on whether the
     * list is not empty and an entry is selected.
     *
     * @param e 	The ListSelectionEvent from the m_retiredTasks JList.
     */
    public void valueChanged(ListSelectionEvent e)
    {
        if (e.getValueIsAdjusting() == false)
        {
            if (m_retiredTasks.getSelectedIndex() == -1)
            {
            	//No selection, disable fire button.
                m_removeTask.setEnabled(false);

            }
            else
            {
            	//Selection, enable the fire button.
                m_removeTask.setEnabled(true);
            }
        }
    }
	

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		String xml_file = 
				"file:///Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xml";
		String xsd_file = 
				"file:////Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xsd";
		Tk_TaskCollection tc = 
			new Tk_TaskCollection
			(
				xml_file,
				xsd_file
			);
		DefaultComboBoxModel<String>ret_tasks = tc.getRetiredListUpdate();
		DefaultComboBoxModel<String>del_tasks = tc.getDeletedListUpdate();
		
		Tk_AdditionalTasks tat = new Tk_AdditionalTasks(ret_tasks, del_tasks);
		
		JFrame jf = new JFrame();
		jf.add(tat);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
		
	}

	public Vector<String> getAddedTasks()
	{
		// TODO Auto-generated method stub
		return m_addedTasks;
	}

    public Vector<String>getRemovedTasks()
    {
    	return m_removedTasks;
    }

}
package Tk_TaskSelectPanel;

import javax.swing.*;


public class Tk_ButtonBox extends Box
{
	private JButton		m_okButton		= null;
	private JButton		m_cancelButton 	= null;
	public Tk_ButtonBox()
	{
		super(BoxLayout.LINE_AXIS);
		m_okButton = new JButton("Ok");
		m_cancelButton = new JButton("Cancel");
		add(m_okButton);
		add(m_cancelButton);
	}
	
	public JButton getOkButton()
	{
		return m_okButton;
	}
	
	public JButton getCancelButton()
	{
		return m_cancelButton;
	}
	
	public static void main(String[] args)
	{
		Tk_ButtonBox tbb = new Tk_ButtonBox();
		JFrame jf = new JFrame("Button Box Test!");
		jf.add(tbb);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}
}
package Tk_TaskSelectPanel;

import java.awt.event.*;
//import java.awt.*;
import javax.swing.*;

import Tk_Configuration.Tk_TaskCollection;


public class Tk_ComboBox extends JComboBox<String>
{
	
	DefaultComboBoxModel<String>m_model = null;
	/**
	 * Construct a Tk_TaskCollection, and add it's DefaultComboBoxModel
	 * m_currentList as the model of this combo box.
	 *
	 * @param uri_string		The uri of the xml containing the lists of
	 * 							tasks to appear in this combo box.
	 * @param schema_string     The uri of the xml schema for the above
	 *                          xml file.
	 */
	public Tk_ComboBox(DefaultComboBoxModel<String>combo_model)
	{
		//m_taskCollection = new Tk_TaskCollection(uri_string, schema_string); //, this);
		m_model = combo_model;
		setModel(m_model);
		if (m_model.getSize() != 0)
		{
			setSelectedIndex(0);
		}
	}
	
	public DefaultComboBoxModel<String>getCurrentList()
	{
		return m_model;
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		JFrame jf = new JFrame();
		jf.setLayout(new BoxLayout(jf.getContentPane(), BoxLayout.X_AXIS));
		Tk_TaskCollection t_col =
		new Tk_TaskCollection
		(
			"file:///Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xml",
			"file:////Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xsd"
		);
		Tk_ComboBox tc = new Tk_ComboBox(t_col.getCurrentList());
		jf.add(tc);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}

}
package Tk_TaskSelectPanel;

import java.util.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.*;
import javax.swing.border.*;

//
// My class imports 
//
import Tk_Configuration.*;

public class Tk_EditTasks extends JFrame implements ActionListener
{
	// The Title for this JFrame
	private static final String EditTitle		= "Edit Tasks";
	//
	// Action commands for the various buttons.
	//
	private static final String LeftAction 		= "left";
	private static final String RightAction 	= "right";
	public	 static final String OkAction		= "ok";
	public static final String CancelAction		= "cancel";
	
	// The supplied DefaultComboBoxModels
	private DefaultComboBoxModel<String> m_curList = null;
	private DefaultComboBoxModel<String> m_retList = null;
	private DefaultComboBoxModel<String> m_delList = null;
	
	// The JList containing the current tasks and a JScrollPane to contain it.
	private JList 				m_currentTasks 		= null;
	private JScrollPane			m_currentScroller   = null;

	// The Panel containing the Additional Tasks list, buttons and text bod.
	private Tk_AdditionalTasks	m_additionalTasks 	= null;

	// The Box containing the copy left/right buttons.
	private Tk_LRButtons		m_moveBox		= null;
	private JButton				m_moveLeft		= null;
	private JButton				m_moveRight		= null;

	// The box containing the Ok and Cancel buttons.
	private Tk_ButtonBox		m_buttonBox		= null;
	private JButton 			m_ok 			= null;
	private JButton				m_cancel 		= null;
	
	// A Box to contain the m_currentTasks JList, the m_additionalTasks panel,
	// and the Tk_LRButtons box between the two - layed out horizontally.
	private Box 				m_topBox		= null;
	
	private Vector<String>m_addCurrent	= new Vector<String>();
	private Vector<String>m_removeCurrent = new Vector<String>();

	//String frame_title,
	public Tk_EditTasks
	(
		DefaultComboBoxModel<String> curTasks,
		DefaultComboBoxModel<String> retTasks,
		DefaultComboBoxModel<String> delTasks
	)
	{
		super(EditTitle);
		m_curList = curTasks;
		m_retList = retTasks;
		m_delList = delTasks;

		// Setup the current tasks JList
		m_currentTasks = new JList<String>();
		m_currentTasks.setModel(m_curList);
		m_currentTasks.setPrototypeCellValue("This is a relatively long task name!");

		// Set up the JScrollbar for the current task list.
		m_currentScroller = new JScrollPane();
		m_currentScroller.getViewport().add(m_currentTasks);
		m_currentScroller.setBorder
		(
			BorderFactory.createTitledBorder
			(
				BorderFactory.createBevelBorder(BevelBorder.LOWERED),
				"Current Tasks:"
			)
		);

		// Set up the Tk_AddtionalTasks panel.
		m_additionalTasks = new Tk_AdditionalTasks
			(
					m_retList,
					m_delList
			);
		
		// Set up the left and right buttons, setup their action commands, and
		// wire them up to this as an ActionListener.
		m_moveBox = new Tk_LRButtons();
		m_moveLeft = m_moveBox.getLeftButton();
		m_moveRight = m_moveBox.getRightButton();
		m_moveLeft.setActionCommand(LeftAction);
		m_moveLeft.addActionListener(this);
		m_moveRight.setActionCommand(RightAction);
		m_moveRight.addActionListener(this);
		
		// Set up the Ok and Cancel buttons, setup their action commands, and
		// wire them up to this as their ActionListener.
		m_buttonBox		= new Tk_ButtonBox();
		m_ok 			= m_buttonBox.getOkButton();
		m_cancel 		= m_buttonBox.getCancelButton();
		m_ok.setActionCommand(OkAction);
		m_ok.addActionListener(this);
		m_cancel.setActionCommand(CancelAction);
		m_cancel.addActionListener(this);
		
		// Setup the TopBox to contain the Current tasks JList, the arrow
		// buttons, and the Tk_AdditionalTasks object.
		m_topBox = new Box(BoxLayout.LINE_AXIS);
		m_topBox.add(m_currentScroller);
		m_topBox.add(m_moveBox);
		m_topBox.add(m_additionalTasks);
		
		// Layout this JFrame with m_topBox at the top, and m_buttonBox at
		// the bottom.
		Box myBox = Box.createVerticalBox();
		myBox.add(m_topBox);
		myBox.add(m_buttonBox);
		Color c1 = new Color(86, 86, 86);
	    Color c2 = new Color(192, 192, 192);
	    Color c3 = new Color(204, 204, 204);
	    Border b1 = new BevelBorder(EtchedBorder.RAISED, c3, c1);
	    Border b2 = new MatteBorder(3,3,3,3,c2);
	    Border b3 = new BevelBorder (EtchedBorder.LOWERED, c3, c1);
	    myBox.setBorder(new CompoundBorder(new CompoundBorder(b1, b2), b3));
	    add(myBox);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		pack();
		setVisible(true);
	}
	
	public JButton getOKButton()
	{
		return m_ok;
	}
	
	public JButton getCancelButton()
	{
		return m_cancel;
	}

	public Vector<String>getAddCurrent()
	{
		return m_addCurrent;
	}
	
	public Vector<String>getRemoveCurrent()
	{
		return m_removeCurrent;
	}
	
	public Vector<String>getAddedTasks()
	{
		return this.m_additionalTasks.getAddedTasks();
	}
	
	public Vector<String>getRemovedTasks()
	{
		return m_additionalTasks.getRemovedTasks();
	}

	/**
	 * FIXME: Need to disable left button when the right list is empty. Also need
	 * the action listener to reenable it.
	 * 
	 */
	@Override
	public void actionPerformed(ActionEvent e)
	{
		if (OkAction.equals(e.getActionCommand()))
		{
			System.out.println(">>>>>>>>>>> OK  OK OK OK OK OK <<<<<<<<<<<<<");
		}
		else if (CancelAction.equals(e.getActionCommand()))
		{
			System.out.println(">>>>>>>>>>> CANCEL CANCEL CANCEL <<<<<<<<<<<<<");
		}
		else if (LeftAction.equals(e.getActionCommand()))
		{
			System.out.println(">>>>>>>>>>> LEFT LEFT LEFT LEFT LEFT <<<<<<<<<<<<<");
			JList<String>retTasks = m_additionalTasks.getRetiredTasks();
			int    index = retTasks.getSelectedIndex();
			String copy_el = m_retList.getElementAt(index);
			System.out.printf("\nSelected Item in JList is: %s\n", copy_el);
			System.out.printf("Indxe of %s in JList is: %d\n", copy_el, index);
			m_retList.removeElementAt(index);
			if (m_retList.getSize() <= index && index > 0)
			{
				index--;
			}
			retTasks.setSelectedIndex(index);
			retTasks.ensureIndexIsVisible(index);
			index = m_curList.getSize();
			m_curList.insertElementAt(copy_el, index);
			m_currentTasks.setSelectedIndex(index);
			m_currentTasks.ensureIndexIsVisible(index);
			m_addCurrent.add(copy_el);
		}
		else if (RightAction.equals(e.getActionCommand()))
		{	
			System.out.println(">>>>>>>>>>> RIGHT  RIGHT  RIGHT  RIGHT <<<<<<<<<<<<<<");
			int index = m_currentTasks.getSelectedIndex();
			String copy_el = m_curList.getElementAt(index);
			m_curList.removeElementAt(index);
			if (m_curList.getSize() <= index && index > 0)
			{
				index--;
			}
			m_currentTasks.setSelectedIndex(index);
			m_currentTasks.ensureIndexIsVisible(index);
			index = m_retList.getSize();
			m_retList.insertElementAt(copy_el, index);
			m_removeCurrent.add(copy_el);
		}
		
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		String xml_file = 
				"file:///Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xml";
		String xsd_file = 
				"file:////Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xsd";
		Tk_TaskCollection tc = 
			new Tk_TaskCollection
			(
				xml_file,
				xsd_file
			);
		DefaultComboBoxModel<String>cur_tasks = tc.getCurrentListUpdate();
		DefaultComboBoxModel<String>ret_tasks = tc.getRetiredListUpdate();
		DefaultComboBoxModel<String>del_tasks = tc.getDeletedListUpdate();
		
		Tk_EditTasks tet = new Tk_EditTasks
		(
			cur_tasks,
			ret_tasks,
			del_tasks
		);
	}
}
package Tk_TaskSelectPanel;

import java.awt.event.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.Rectangle;

import javax.swing.*;
import javax.swing.plaf.basic.BasicArrowButton;
import javax.swing.Box.Filler;
import javax.swing.border.*;

@SuppressWarnings("serial")
public class Tk_LRButtons extends Box
{
	JButton m_moveLeftButton;
	JButton m_moveRightButton;
	
	public Tk_LRButtons()
	{
		super(BoxLayout.PAGE_AXIS);
		m_moveLeftButton = new BasicArrowButton(BasicArrowButton.WEST);
		Rectangle r = new Rectangle(100, 100, 0, 0);
		/*Dimension d = new Dimension(100, 100);
		m_moveLeftButton.setPreferredSize(d);
		m_moveLeftButton.setMinimumSize(d);
		m_moveLeftButton.setMaximumSize(d);*/
		m_moveLeftButton.setBounds(r);
		m_moveRightButton = new BasicArrowButton(BasicArrowButton.EAST);
		/*m_moveRightButton.setPreferredSize(d);
		m_moveRightButton.setMinimumSize(d);
		m_moveRightButton.setMaximumSize(d);
		*/
		m_moveRightButton.setBounds(r);
		add(new Filler(new Dimension(10, 100), new Dimension(10, 100), new Dimension(10, 100)));
		add(m_moveLeftButton);
		add(m_moveRightButton);
		add(new Filler(new Dimension(10, 100), new Dimension(20, 100), new Dimension(20, 100)));
		
		setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));
	}
	
	public JButton getLeftButton()
	{
		return m_moveLeftButton;
	}
	
	public JButton getRightButton()
	{
		return m_moveRightButton;
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		JFrame jf = new JFrame();
		Tk_LRButtons lrb = new Tk_LRButtons();
		jf.add(lrb);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);

		ActionListener al =
			new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					if ("left".equals(e.getActionCommand()))
					{
						System.out.println("Left Button Clicked!");
					}
					else if ("right".equals(e.getActionCommand()))
					{
						System.out.println("Right Button Clicked!");
					}
				}
			};
		lrb.getLeftButton().addActionListener(al);
		lrb.getRightButton().addActionListener(al);
	}

}
package Tk_TaskSelectPanel;

import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;

import java.awt.*;
import java.awt.event.*;

// My Imports
import Tk_Configuration.Tk_TaskCollection;

/**
 * A panel that holds the task selection combo box, and 
 * @author michaelwebster
 *
 */
public class Tk_TaskSelect extends JPanel implements ActionListener
{
	// The action commands to supply to the Tk_ComboBox and JButton.
	public static final String SelectString 	= "Select";
	public static final String EditString		= "Edit";

	private Tk_TaskCollection 	m_taskCollection = null;
	private Tk_ComboBox 		m_cb = null;
	private JButton         	m_editButton = null;
	
	// The Tk_EditTasks panel that allows the user to add or remove tasks.
	private Tk_EditTasks    	m_editTasks = null;
	
	public Tk_TaskSelect(String xml_fname, String schema_fname)
	{
		// Create the Task Collection object by reading the xml from the file
		// named uri_string
		m_taskCollection = new Tk_TaskCollection(xml_fname, schema_fname);
		
		// Create the Combo box by providing it with a list of tasks, and add
		// an action listener to it.
		m_cb = new Tk_ComboBox(m_taskCollection.getCurrentList());
		m_cb.setActionCommand(SelectString);
		m_cb.addActionListener(this);
		m_cb.setPrototypeDisplayValue
		(
			"This is a very long task name, perhaps it will help"
		);
		
		// Create the Edit Tasks button, and add and action listener to it.
		m_editButton = new JButton("Edit Tasks");
		m_editButton.setActionCommand(EditString);
		m_editButton.addActionListener(this);
		
		// Use a simple FlowLayout to layout the combo box and button side by
		// side.
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		setLayout(fl);
		add(m_cb);
		add(m_editButton);
		setBorder
		(
			BorderFactory.createTitledBorder
			(
				BorderFactory.createBevelBorder(BevelBorder.RAISED),
				"Select Task:"
			)
		);
	}

	public String getSelected()
	{
		return (String)m_cb.getSelectedItem();
	}
	
	public Tk_ComboBox getComboBox()
	{
		return m_cb;
	}

	@Override
	public void actionPerformed(ActionEvent e)
	{
		if (SelectString.equals(e.getActionCommand()))
		{
			System.out.println("Selection made:");
			System.out.println("Selection is " + m_cb.getSelectedItem());
		}
		else if (EditString.equals(e.getActionCommand()))
		{
			System.out.println("Edit button pressed.");
			m_editTasks = new Tk_EditTasks
			(
					m_taskCollection.getCurrentListUpdate(),
					m_taskCollection.getRetiredListUpdate(),
					m_taskCollection.getDeletedListUpdate()
			);
			m_editTasks.getOKButton().addActionListener(this);
			m_editTasks.getCancelButton().addActionListener(this);
		}
		else if (m_editTasks.OkAction.equals(e.getActionCommand()))
		{
			System.out.println("Picked Up Ok in Tk_TaskSelect.");
			System.out.println("Reconciling models(true)");
			m_taskCollection.reconcileModels(true);
			System.out.println("Destroying m_editTasks window.");
			m_editTasks.setVisible(false);
			/*m_addCurrent.addAll(m_editTasks.getAddCurrent());
			m_removeCurrent.addAll(m_editTasks.getRemoveCurrent());
			m_addedTasks.addAll(m_editTasks.getAddedTasks());
			m_removedTasks.addAll(m_editTasks.getRemovedTasks());*/
			m_editTasks.dispose();
			System.out.println("The Dom after reconcie true is:");
			m_taskCollection.printDom();
		}
		else if (m_editTasks.CancelAction.equals(e.getActionCommand()))
		{
			System.out.println("Picked Up Cancel in Tk_TaskSelect.");
			System.out.println("Reconciling models(false)");
			m_taskCollection.reconcileModels(false);
			System.out.println("Destroying m_editTasks window.");
			m_editTasks.setVisible(false);
			m_editTasks.dispose();
			System.out.println("The Dom after reconcie false is:");
			m_taskCollection.printDom();
		}
	}
	
	public Tk_TaskCollection getTaskCollection()
	{
		return m_taskCollection;
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		//JFrame.setDefaultLookAndFeelDecorated(false);
		JFrame jf = new JFrame();
		Tk_TaskSelect ts = new Tk_TaskSelect
		(
			"file:///Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xml",
			"file:////Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Configuration/TestData/TK_TaskList.xsd"
		);
		jf.add(ts);
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		//
		// Set the JFrame jf into the centre of the screen.
		//
		Dimension dim = jf.getToolkit().getScreenSize();
		jf.setLocation
		(
				dim.width/2 - jf.getWidth()/2,
				dim.height/2 - jf.getHeight()/2
		);
		System.out.println(dim.toString());
		jf.setVisible(true);
		Tk_TaskCollection tc = ts.getTaskCollection();
		System.out.println("The DOM starts like this:");
		tc.printDom();
	}

}
package Tk_utils;

import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

import javax.xml.parsers.*;
import org.w3c.dom.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

public class DocWriteDom
{
	public static void main(String[] av) throws IOException
	{
		DocWriteDom dw = new DocWriteDom();
		Document doc = dw.makeDoc();
		
		// Sadly, the write() method is not in the DOM spec, so we
		// have to cast the Document to its implementing class
		// in order to call the Write method.
		//
		// WARNING
		//
		// This code therefore depends upon the particular
		// parser implementation.
		//
		//((org.apache.crimson.tree.XmlDocument)doc).write(System.out);
		try
		{
			Transformer transformer = TransformerFactory.newInstance( ).newTransformer( );
			Source source = new DOMSource(doc);
			Result output = new StreamResult( System.out );
			transformer.transform(source, output);
		}
		catch (Exception e)
		{
			System.out.println("Caught Transformer exception!");
			System.out.println(e.toString());
		}
	}
	
	/** Generate the XML document */
	protected Document makeDoc()
	{
		try
		{
			DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();
			DocumentBuilder parser = fact.newDocumentBuilder();
			Document doc = parser.newDocument();
			Node root = doc.createElement("Poem");
			doc.appendChild(root);
			Node stanza = doc.createElement("Stanza");
			root.appendChild(stanza);
			Node line = doc.createElement("Line");
			stanza.appendChild(line);
			line.appendChild(doc.createTextNode("Once, upon a midnight dreary"));
			line = doc.createElement("Line");
			stanza.appendChild(line);
			line.appendChild(doc.createTextNode("While I pondered, weak and weary"));
			return doc;
		}
		catch (Exception ex)
		{
			System.err.println("+============================+");
			System.err.println("| XML Error |");
			System.err.println("+============================+");
			System.err.println(ex.getClass( ));
			System.err.println(ex.getMessage( ));
			System.err.println("+============================+");
			return null;
		}
	}
}
package Tk_utils;

import java.util.Properties;

public class ListProperties {

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		Properties p = System.getProperties();
		
		System.out.println("Printing Property List:");
		p.list(System.out);
		
		System.out.println("<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>");
		String ud = System.getProperty("user.home");
		System.out.println("User directory is:");
		System.out.println(ud);
	}

}
/**
 * 
 */
/**
 * @author michaelwebster
 *
 */
package Tk_utils;package Tk_utils;
import javax.xml.datatype.*;
import java.lang.*;
import java.util.*;
import java.awt.*;
import java.awt.geom.*;
import javax.swing.*;


public class TestDateStrings
{

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		Date d = new Date();
		System.out.println(d.toString());
		GregorianCalendar g = new GregorianCalendar(d.getYear(), d.getMonth(), d.getDay());
		System.out.println(g.getTime().toGMTString());
		System.out.println(g.getTime().toLocaleString());
		System.out.println(g.getTime().toString());
		
		//String regex = new String("\\s");
		String[]splits = d.toString().split("\\s");
		for (int i = 0; i < splits.length; i++)
		{
			System.out.printf("splits[%s] is:%s\n", i, splits[i]);
		}
		
		JLabel jl = new JLabel();
		Graphics gr = jl.getGraphics();
		if (gr == null)
		{
			System.out.println("Graphics is null");
		}
		else
		{
			System.out.println("Got a grphics object.");
		}
		
		jl.setVisible(true);
		gr = jl.getGraphics();
		if (gr == null)
		{
			System.out.println("Set label visible: Graphics is null");
		}
		else
		{
			System.out.println("Set Label visible: Got a grphics object.");
		}
		
		JPanel jp = new JPanel();
		jp.add(jl);
		gr = jl.getGraphics();
		if (gr == null)
		{
			System.out.println("Graphics is null");
		}
		else
		{
			System.out.println("Got a grphics object.");
		}
		jp.setVisible(true);
		gr = jl.getGraphics();
		if (gr == null)
		{
			System.out.println("Graphics is null");
		}
		else
		{
			System.out.println("Got a grphics object.");
		}
		
	}

}
package Tk_utils;

public abstract class Tk_Converter<T1, T2>
{
	public abstract T2 convertValForward(T1 val);
	
	public abstract T1 convertValBack(T2 val);
	
	public String getStringFirst(T1 val){ return null; }
		
	
	public String getStringSecond(T2 val){ return null; }
}

package Tk_utils;

import javax.xml.datatype.*;

import java.util.Date;

/**
 * For a conversion from Duration to Long, we'll simply return the number of
 * seconds represented by the duration, and convert a seconds number into
 * a Duration.
 *
 * @author michaelwebster
 *
 */
public class Tk_DurationConverter extends Tk_Converter<Duration, Long>
{
	/**
	 * Convert from a Duration to a value in seconds to the closest minute.
	 */
	@Override
	public Long convertValForward(Duration val)
	{
		long seconds = val.getTimeInMillis(new Date()) / 1000;
		seconds = seconds - (seconds % 60);
		return seconds;
	}

	/**
	 * Convert from a value in seconds to a duration to the nearest minute.
	 */
	@Override
	public Duration convertValBack(Long val)
	{
		long seconds = val - val % 60;
		DatatypeFactory dtf = null;
		try
		{
			dtf = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException err)
		{
			System.out.println
			(
				"Error: Tk_DurationConverter(long)."
			);
			System.out.println("Caught Exception:");
			System.out.println(err.getMessage());
			System.exit(-1);
		}
		return dtf.newDuration(1000 * seconds);
	}
	
	

	@Override
	public String getStringFirst(Duration val)
	{
		String dur = String.format
				(
					"%02d:%02d",
					val.getHours(),
					val.getMinutes()
					//val.getSeconds()
				);
		return dur;
	}

	@Override
	public String getStringSecond(Long val)
	{
		long hours = val / 3600;
		long mins = (val % 3600) / 60;
				
		return String.format("%02d:%02d", hours, mins);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		Tk_DurationConverter tdc = new Tk_DurationConverter();
		
		Duration d1 = tdc.convertValBack((long)1);
		String s = tdc.getStringFirst(d1);
		System.out.printf("1 second converted to a duration is:\n%s\n", s);
		
		Duration d2 = tdc.convertValBack((long)60);
		s = tdc.getStringFirst(d2);
		System.out.printf("60 second converted to a duration is:\n%s\n", s);
		
		Duration d3 = tdc.convertValBack((long)60*60);
		s = tdc.getStringFirst(d3);
		System.out.printf("1 hour second converted to a duration is:\n%s\n", s);
		
		Duration d4 = tdc.convertValBack((long)(60*60 * 3 + 60 * 33 + 45));
		s = tdc.getStringFirst(d4);
		System.out.printf("3hrs, 33 minutes and 45 seconds converted to a duration is:\n%s\n", s);
		
		System.out.println("Now convert back longs....");
		long l = tdc.convertValForward(d1);
		s = tdc.getStringSecond(l);
		System.out.printf("1 second converted back to long is:\n%s\n", s);
		
		l = tdc.convertValForward(d2);
		s = tdc.getStringSecond(l);
		System.out.printf("60 second converted back to long is:\n%s\n", s);
		
		l = tdc.convertValForward(d3);
		s = tdc.getStringSecond(l);
		System.out.printf("1 hour converted to a long is:\n%s\n", s);
		
		l = tdc.convertValForward(d4);
		s = tdc.getStringSecond(l);
		System.out.printf("3 hours 33 minutes and 45 seconds converted to a long is:\n%s\n", s);
	}

}
package Tk_utils;

import java.util.*;
import java.io.*;

public class Tk_FileUtil
{
	public static String Tk_XmlDir = File.separator + ".TimeKeeper";

	public static Map<String,String>getXmlFiles
	(
		String t_xml,
		String t_xsd,
		String h_xml,
		String h_xsd
	)
	{
		HashMap<String, String>pmap = new HashMap<String, String>();
		pmap.put(t_xml, null);
		pmap.put(t_xsd, null);
		pmap.put(h_xml, null);
		pmap.put(h_xsd, null);
		String home = System.getProperty("user.home");
		String tk_dir = home.concat(Tk_XmlDir);

		// Check for the user.home/.TimeKeeper directory, and create it if it
		// is not there
		File tkd = new File(tk_dir);
		
		if (!tkd.exists())
		{
			if (!tkd.mkdir())
			{
				System.out.printf("Couldn't Create Directory: %s\n", tkd.getAbsoluteFile());
				System.exit(0);
			}
			tkd.setReadable(true, true);
		}

		Iterator<String> it = pmap.keySet().iterator();
		while (it.hasNext())
		{
			String org_string = it.next();
			String target_file = org_string.substring(t_xml.lastIndexOf(File.separator));
			target_file = tk_dir.concat(target_file);
			pmap.put(org_string, target_file);
			
			System.out.printf("%s: Target is: %s\n", org_string, pmap.get(org_string));

			File tfile = new File(target_file);
			if (!tfile.exists())
			{
				try
				{
					tfile.createNewFile();
					
					// Now open the template for this file from the resource, and
					// write the contents of that file into the newly created file.
					InputStream is = Tk_FileUtil.class.getResourceAsStream(org_string);
					FileOutputStream os = new FileOutputStream(tfile);
					
					int read = 0;
					byte[]bytes = new byte[1024];
					while ((read = is.read(bytes)) != -1)
					{
						os.write(bytes, 0, read);
					}
						
				}
				catch (IOException e)
				{
					System.out.println("Tk_FileUtil.getXmlFiles IOException!");
					System.out.println(e.getMessage());
					System.exit(0);
				}
				catch (SecurityException e)
				{
					System.out.println("Tk_FileUtil.getXmlFiles SecurityException!");
					System.out.println(e.getMessage());
					System.exit(0);					
				}
			}
		}		
		return pmap;
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		String TaskXmlTemplate = "/Tk_Configuration/TestData/TK_TaskList.xml";
		String TaskXmlFile = null;
		String TaskXsdTemplate = "/Tk_configuration/TestData/TK_TaskList.xsd";
		String TaskXsdFile = "null";
		String HistoryXmlTemplate = "/Tk_Configuration/TestData/TK_History.xml";
		String HistoryXmlFile = null;
		String HistoryXsdTemplate = "/Tk_Configuration/TestData/TK_History.xsd";
		String HistoryXsdFile = null;
		
		Map<String, String>fmap =
				getXmlFiles
				(
					TaskXmlTemplate,
					TaskXsdTemplate,
					HistoryXmlTemplate,
					HistoryXsdTemplate
				);
		
		Iterator<String> it = fmap.keySet().iterator();
		while (it.hasNext())
		{
			String c_string = it.next();
			File c_file = new File(fmap.get(c_string));
			System.out.printf("Deleting file: %s\n", c_file.getAbsoluteFile());
			//c_file.delete();
		}
		File f = new File(System.getProperty("user.home").concat(Tk_XmlDir));
		//f.delete();
	}

}
package Tk_utils;

public class Tk_LongLong extends Tk_Converter<Long, Long>
{

	@Override
	public Long convertValForward(Long val)
	{
		return val;
	}

	@Override
	public Long convertValBack(Long val)
	{
		return val;
	}


	@Override
	public String getStringFirst(Long val)
	{
		return String.format("%d", val);
	}

	@Override
	public String getStringSecond(Long val)
	{
		return String.format("%d", val);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
	
	}

}
package Tk_utils;
import javax.xml.XMLConstants;
import javax.xml.validation.*;
import org.xml.sax.*;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;

public class Tk_ValidateXML
{
	public static void main( String [] args ) throws Exception
	{
		if ( args.length != 2 )
		{
			System.err.println("usage: Tk_ValidateXML xmlfile.xml xsdfile.xsd");
			System.exit(1);
		}
		
		String xmlfile = args[0], xsdfile = args[1];
		SchemaFactory factory =
				SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
		Schema schema = factory.newSchema(new StreamSource(xsdfile));
		Validator validator = schema.newValidator();
		
		ErrorHandler errHandler = new ErrorHandler()
		{
			public void error( SAXParseException e){ System.out.println(e); }
			public void fatalError( SAXParseException e) { System.out.println(e); }
			public void warning( SAXParseException e) { System.out.println(e); }
        };
        
        validator.setErrorHandler( errHandler );
        try
        {
        	validator.validate( new SAXSource(new InputSource(xmlfile)));
        }
        catch ( SAXException e )
        {
        	// Invalid Document, no error handler
        	System.exit(-1);
        }
        System.out.printf("The xml file:\n\t%s\nwas validated with schema:\n\t%s\n", xmlfile, xsdfile);
        
	}
}

package Tk_utils;
import java.io.*;
import java.net.*;
import org.w3c.dom.*;
import javax.xml.parsers.*;
import javax.xml.XMLConstants;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;
//import javax.xml.transform.Result;
//import javax.xml.transform.Source;
//import javax.xml.transform.Transformer;
//import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.validation.*;
import org.xml.sax.*;
import java.io.*;

import java.net.*;

public class Tk_XmlUtil
{
	/**
	 * Convenience function for getting an XML schema for validation from the
	 * file schema_file.
	 * 
	 * @param schema_file	The file containing the xml schema.
	 * @return				A javax.xml.validation.Schema object created from
	 * 						schema_file
	 * 
	 * @throws SAXException          	thrown by SchemaFactory.newSchema
	 * @throws NullPointerException		thrown by SchemaFactory.newSchema
	 */
	public static Schema getSchema(File schema_file)
			throws SAXException, NullPointerException
	{
		SchemaFactory factory =
				SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
		return factory.newSchema(schema_file);
		
	}

	/**
	 * Read the xsd file and return a new xml Schema instance from it.
	 *
	 * @param xsd	A string containing the URI for the xml schema file.
	 *
	 * @return	An xml Schema object for the schema described in xsd.
	 */
	public static Schema getSchema(String xsd_name)
	{
		/*
		 * Create a file object for the xml schema we will be validating against.
		 */
		File xsd_file = null;
		try
		{
			xsd_file = new File(xsd_name);
		}
		catch (IllegalArgumentException e)
		{
			System.out.printf
			(
				"Tk_XmlUtil.getSchema: Failed to create File object for %s.\n",
				xsd_name
			);
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());
			System.exit(-1);
		}
		catch (NullPointerException e)
		{
			System.out.printf
			(
				"Tk_XmlUtil.getSchema: Failed to create File object for %s.\n",
				xsd_name
			);
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());
			System.exit(-1);
		}
		
		/*
		 * Get the xml schema object
		 */
		Schema xml_schema = null;
		if (xsd_file.exists())
		{
			try
			{
				 xml_schema = Tk_XmlUtil.getSchema(xsd_file);
			}
			catch (SAXException e)
			{
				System.out.printf
				(
					"Tk_XmlUtil: Syntax Error in schema %s\n",
					xsd_file.getAbsolutePath()
				);
				System.out.println(e.getMessage());
				System.out.println(e.getStackTrace());
				System.exit(-1);
			}
		}
		return xml_schema;
	}

	/**
	 * Get the first descendent of Element with tag = name.
	 *
	 * @param element 	The element to search from.
	 * @param name		The tagname of the element we are looking for.
	 *
	 * @return The Element we are searching for, it it is in the tree under
	 * 			element.
	 */
	public static Element getFirstElement(Element element, String name)
	{
		NodeList nl = element.getElementsByTagName( name );
		if ( nl.getLength() < 1 ) 
		{
			//throw new RuntimeException("Element: "+element+" does not contain: "+name);
			return null;
		}
		return (Element)(nl.item(0));
	}

	/**
	 * Return the string data contained in the node with tag == name under
	 * the Element node.
	 *
	 * @param node 	The node to search under.
	 * @param name  The tagname for the element we are looking for.
	 *
	 * @return		A String containing the text in the first Element under
	 * 				node that has tagname == name.
	 */
	public static String getSimpleElementText(Element node, String name)
	{
		Element namedElement = getFirstElement( node, name);
		return getSimpleElementText(namedElement);
	}
	
	/**
	 * Get the text content of the text element node.
	 * @param node  A text element we want to extract the value of.
	 * @return      A string containing the text read from node.
	 */
	public static String getSimpleElementText(Element node)
	{
		StringBuffer sb = new StringBuffer();
		NodeList children = node.getChildNodes();
		for(int i=0; i<children.getLength(); i++)
		{
			Node child = children.item(i);
			if ( child instanceof Text )
				sb.append( child.getNodeValue() );
		}
		return sb.toString();
	}
	
	/**
	 * Verify an xml document according to a schema, and parse the xml to
	 * create a Dom.
	 *
	 * @param xml 	Name of the file containing the xml.
	 * @param xsd	Name of the file containing the xml schema.
	 *
	 * @return		A document created by the parser from the xml file. 
	 */
	public static Document createDocument(String xml_name, String xsd_name)
	{
		File 	xml_file		= null;
		File	xsd_file		= null;

		/*
		 * Create a file object for the xml file we will be reading and/or writing.
		 */
		try
		{
			xml_file = new File(xml_name);
		}
		catch (IllegalArgumentException e)
		{
			System.out.printf
			(
				"Tk_XmlUtil.createDocument: Failed to create File object for %s.\n",
				xml_name
			);
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());
			System.exit(-1);
		}
		catch (NullPointerException e)
		{
			System.out.printf
			(
				"Tk_XmlUtil.createDocument: Failed to create File object for %s.\n",
				xml_name
			);
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());
			System.exit(-1);
		}

		/*
		 * Create a file object for the xml schema we will be validating against.
		 */
		try
		{
			xsd_file = new File(xsd_name);
		}
		catch (IllegalArgumentException e)
		{
			System.out.printf
			(
				"Tk_XmlUtil.createDocument: Failed to create File object for %s.\n",
				xsd_name
			);
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());
			System.exit(-1);
		}
		catch (NullPointerException e)
		{
			System.out.printf
			(
				"Tk_XmlUtil.createDocument: Failed to create File object for %s.\n",
				xsd_name
			);
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());
			System.exit(-1);
		}

		
		/*
		 * Get the xml schema object
		 */
		Schema xml_schema = null;
		if (xsd_file.exists())
		{
			try
			{
				 xml_schema = Tk_XmlUtil.getSchema(xsd_file);
			}
			catch (SAXException e)
			{
				System.out.printf
				(
					"Tk_XmlUtil: Syntax Error in schema %s\n",
					xsd_file.getAbsolutePath()
				);
				System.out.println(e.getMessage());
				System.exit(-1);
			}
		}
		
		/*
		 * Begin dealing with the xml file. 
		 */
		if (!xml_file.exists())
		{
			System.out.printf
			(
				"Error: file %s does not exist in call to Tk_XmlUtil constructor.",
				xml_file.getAbsoluteFile()
			);
			System.exit(-1);
		}	

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		dbf.setNamespaceAware(false);
		dbf.setSchema(xml_schema);
		dbf.setValidating(false);

		DocumentBuilder doc_builder = null;
		try
		{
			doc_builder = dbf.newDocumentBuilder();
		}
		catch (ParserConfigurationException e)
		{
			System.out.printf
			(
				"Tk_XmlUtil.createDocument: Error in configuration of the DocBuilder instance!\n%s",
				e.getMessage()
			);
			System.out.println(e.getStackTrace());
			System.exit(-1);
		}
	
		/*
		 * Setup and set the error handler for the parser.
		 */
		ErrorHandler errHandler = new ErrorHandler()
		{
			public void error( SAXParseException e)
			{
				System.out.println("In createDocument:");
				System.out.println(e.getMessage());
			}
			public void fatalError( SAXParseException e)
			{
				System.out.println("In createDocument:");
				System.out.println(e.getMessage());
				
			}
			public void warning( SAXParseException e)
			{
				System.out.println("In createDocument:");
				System.out.println(e.getMessage());
			}
        };
        doc_builder.setErrorHandler(errHandler);
        
        /*
         * Build the dom.
         */
        Document dom = null;
        try
        {
        	dom = doc_builder.parse(xml_file);
        }
        catch (SAXException e)
        {
        	// Error handler should have picked this up.
        	System.out.println("Tk_XmlUtil.createDocument: Error!");
        	System.out.println("NOTE: I don't think we should get here.");
        	System.out.println("TkTaskCollection.createDocument(): SAXException!");
        	System.out.printf
        	(
        		"Exception occured during parse of %s\n",
        		xml_file.getAbsolutePath()
        	);
        	System.out.printf("%s\n", e.getMessage());
        	System.out.println(e.getStackTrace());
        	System.exit(-1);
        }
        catch (IOException e)
        {
        	System.out.println("Tk_XmlUtil.createDocument(): IO Exception");
        	System.out.printf("Couldn't parse file: %s\n", xml_file.getAbsolutePath());
        	System.out.printf("%s\n", e.getMessage());
        	System.out.println(e.getStackTrace());
        	System.exit(-1);
        }
        catch (IllegalArgumentException e)
        {
        	System.out.println("TkXmlUtil.createDocument(): Illegal Argument!");
        	System.out.printf("Couldn't parse file: %s\n", xml_file.getAbsolutePath());
        	System.out.printf("%s\n", e.getMessage());
        	System.out.println(e.getStackTrace());
        	System.exit(-1);
        }
        return dom;
	}

	/**
	 * Create and return a formatted string of xml from the supplied dom.
	 *
	 * @param dom 	The Dom we want to convert to a formatted xml string.
	 *
	 * @return		A string containing reasonably formatted xml.
	 */
	public static String formatDoc(Document dom)
	{
		try
		{
			Source source = new DOMSource(dom);
			StreamResult xmlOutput = new StreamResult(new StringWriter());
			Transformer transformer = TransformerFactory.newInstance( ).newTransformer( );
			//transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "testing");
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			transformer.transform(source, xmlOutput);
			return xmlOutput.getWriter().toString();
		}
		catch (Exception e)
		{
			System.out.println("Caught Transformer exception!");
			System.out.println(e.getMessage());
		}
		return "";
	}
	
	/**
	 * Create an empty DOM document that conforms to the schema file xsd.
	 *
	 * @param xsd 	A URI for the schema that applies to the document.
	 *
	 * @return	An empty xml DOM Document.
	 */
	public static Document createEmptyDom(String xsd)
	{
		Schema schema = getSchema(xsd);
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		dbf.setValidating(true);
		dbf.setSchema(schema);
		
		DocumentBuilder doc_builder = null;
		try
		{
			doc_builder = dbf.newDocumentBuilder();
		}
		catch (ParserConfigurationException e)
		{
			System.out.printf
			(
				"Error: in configuration of the DocBuilder instance!\n%s",
				e.toString()
			);
			System.exit(-1);
		}

		/*
		 * Setup and set the error handler for the parser.
		 */
		ErrorHandler errHandler = new ErrorHandler()
		{
			public void error( SAXParseException e){ System.out.println(e); }
			public void fatalError( SAXParseException e) { System.out.println(e); }
			public void warning( SAXParseException e) { System.out.println(e); }
        };
        doc_builder.setErrorHandler(errHandler);
        
        // Return a document created by this doc_builder.
        return doc_builder.newDocument();
	}

	/**
	 * Create an empty DOM document that conforms to the schema file xsd.
	 *
	 * @param xsd 	A URI for the schema that applies to the document.
	 *
	 * @return	An empty xml DOM Document.
	 */
	public static Document createEmptyDom()
	{
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		dbf.setValidating(false);
		
		DocumentBuilder doc_builder = null;
		try
		{
			doc_builder = dbf.newDocumentBuilder();
		}
		catch (ParserConfigurationException e)
		{
			System.out.printf
			(
				"Error: in configuration of the DocBuilder instance!\n%s",
				e.toString()
			);
			System.exit(-1);
		}

		/*
		 * Setup and set the error handler for the parser.
		 */
		ErrorHandler errHandler = new ErrorHandler()
		{
			public void error( SAXParseException e){ System.out.println(e); }
			public void fatalError( SAXParseException e) { System.out.println(e); }
			public void warning( SAXParseException e) { System.out.println(e); }
        };
        doc_builder.setErrorHandler(errHandler);
        
        // Return a document created by this doc_builder.
        return doc_builder.newDocument();
	}

	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		String xml_file = 
				"/Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Utils/TestData/TK_HistoryExample.xml";
				//"file:///Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Utils/TestData/TK_TaskList.xml";
		String xsd_file = 
				"/Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Utils/TestData/TK_History.xsd";
				//"file:////Users/michaelwebster/Documents/workspace/TimeKeeper/src/Tk_Utils/TestData/TK_TaskList.xsd";
		
		Document dom = createDocument(xml_file, xsd_file);
		String f_output = formatDoc(dom);
		
		System.out.println("The Formatted Output from the formatDoc method is:\n\n");
		System.out.printf("%s", f_output);

	}

}
